"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[68391],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,g=d["".concat(s,".").concat(m)]||d[m]||p[m]||a;return n?r.createElement(g,i(i({ref:t},u),{},{components:n})):r.createElement(g,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},97672:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var r=n(87462),o=n(63366),a=(n(67294),n(3905)),i=["components"],l={id:"types",title:"Types",description:"Explanation for the types module of Polygon Edge.",keywords:["docs","polygon","edge","architecture","module","types","marshaling"]},s=void 0,c={unversionedId:"edge/architecture/modules/types",id:"edge/architecture/modules/types",title:"Types",description:"Explanation for the types module of Polygon Edge.",source:"@site/docs/edge/architecture/modules/types.md",sourceDirName:"edge/architecture/modules",slug:"/edge/architecture/modules/types",permalink:"/matic-docs/docs/edge/architecture/modules/types",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/edge/architecture/modules/types.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686625626,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"types",title:"Types",description:"Explanation for the types module of Polygon Edge.",keywords:["docs","polygon","edge","architecture","module","types","marshaling"]},sidebar:"edge",previous:{title:"Storage",permalink:"/matic-docs/docs/edge/architecture/modules/storage"},next:{title:"Syncer",permalink:"/matic-docs/docs/edge/architecture/modules/syncer"}},u={},p=[{value:"Overview",id:"overview",level:2},{value:"RLP Encoding / Decoding",id:"rlp-encoding--decoding",level:2}],d={toc:p};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Types")," module implements core object types, such as:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Address")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Hash")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Header")),(0,a.kt)("li",{parentName:"ul"},"lots of helper functions")),(0,a.kt)("h2",{id:"rlp-encoding--decoding"},"RLP Encoding / Decoding"),(0,a.kt)("p",null,"Unlike clients such as GETH, the Polygon Edge doesn't use reflection for the encoding.",(0,a.kt)("br",null),"\nThe preference was to not use reflection because it introduces new problems, such as performance\ndegradation, and harder scaling."),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Types")," module provides an easy-to-use interface for RLP marshaling and unmarshalling, using the FastRLP package."),(0,a.kt)("p",null,"Marshaling is done through the ",(0,a.kt)("em",{parentName:"p"},"MarshalRLPWith")," and ",(0,a.kt)("em",{parentName:"p"},"MarshalRLPTo")," methods. The analogous methods exist for\nunmarshalling."),(0,a.kt)("p",null,"By manually defining these methods, the Polygon Edge doesn't need to use reflection. In ",(0,a.kt)("em",{parentName:"p"},"rlp_marshal.go"),", you can find\nmethods for marshaling:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Bodies")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Blocks")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Headers")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Receipts")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Logs")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Transactions"))))}m.isMDXComponent=!0}}]);