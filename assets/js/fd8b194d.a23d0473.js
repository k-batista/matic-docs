"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[76124],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},36463:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var r=n(87462),a=n(63366),o=(n(67294),n(3905)),i=["components"],l={id:"syncer",title:"Syncer",description:"Explanation for the syncer module of Polygon Edge.",keywords:["docs","polygon","edge","architecture","module","synchronization"]},s=void 0,c={unversionedId:"main-edge/architecture/modules/syncer",id:"main-edge/architecture/modules/syncer",title:"Syncer",description:"Explanation for the syncer module of Polygon Edge.",source:"@site/docs/main-edge/architecture/modules/syncer.md",sourceDirName:"main-edge/architecture/modules",slug:"/main-edge/architecture/modules/syncer",permalink:"/matic-docs/docs/main-edge/architecture/modules/syncer",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/main-edge/architecture/modules/syncer.md",tags:[],version:"current",lastUpdatedBy:"Kennedy Batista",lastUpdatedAt:1686621530,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"syncer",title:"Syncer",description:"Explanation for the syncer module of Polygon Edge.",keywords:["docs","polygon","edge","architecture","module","synchronization"]}},p={},u=[{value:"Overview",id:"overview",level:2},{value:"Bulk Sync",id:"bulk-sync",level:3},{value:"Watch Sync",id:"watch-sync",level:3},{value:"Performance report",id:"performance-report",level:2}],d={toc:u};function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"This module contains the logic for the synchronization protocol. It is used for syncing a new node with the running network, or validating/inserting new blocks for the nodes which do not participate in the consensus (non-validators)."),(0,o.kt)("p",null,"The Polygon Edge uses ",(0,o.kt)("strong",{parentName:"p"},"libp2p")," as the networking layer, and on top of that runs ",(0,o.kt)("strong",{parentName:"p"},"gRPC"),"."),(0,o.kt)("p",null,"There are essentially 2 sync types in Polygon Edge:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Bulk Sync  - sync a large range of blocks at a time"),(0,o.kt)("li",{parentName:"ul"},"Watch Sync - sync on a per-block basis")),(0,o.kt)("h3",{id:"bulk-sync"},"Bulk Sync"),(0,o.kt)("p",null,"The steps for Bulk Syncing are pretty straightforward to accomodate the goal of Bulk Sync - sync as many blocks as possible (available) from the other peer in order to catch up, as quickly as possible."),(0,o.kt)("p",null,"This is the flow of the Bulk Sync process:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"}," Determine if the node needs to Bulk Sync ")," - In this step, the node checks the peer map to see if there is anyone who has a bigger block number than what the node has locally"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"}," Find the best peer (using the sync peer map) ")," -  In this step the node finds the best peer to sync with based on the criteria mentioned in the example above."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"}," Open a bulk sync stream ")," - In this step the node opens a gRPC stream to the best peer in order to bulk sync blocks from the common block number"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"}," The best peer closes the stream when done bulk sending ")," - In this step the best peer the node is syncing with will close the stream as soon as it sends all available blocks that it has"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"}," When done bulk syncing, check if the node is a validator ")," - In this step, the stream is closed by the best peer, and the node needs to check if they are a validator after bulk syncing.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If they are, they jump out of sync state and start participating in the consensus"),(0,o.kt)("li",{parentName:"ul"},"If they are not, they continue to ",(0,o.kt)("strong",{parentName:"li"}," Watch Sync "))),(0,o.kt)("h3",{id:"watch-sync"},"Watch Sync"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The step for Watch Syncing is only executed if the node is not a validator, but a regular non-validator node in the network that just listens for oncoming blocks.")),(0,o.kt)("p",null,"The behavior of Watch Sync is pretty straightforward, the node is already synced up with the rest of the network and only needs to parse new blocks that are coming in."),(0,o.kt)("p",null,"This is the flow of the Watch Sync process:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"}," Add a new block when a peer's status is updated ")," - In this step the nodes listen for the new block events, when it has a new block it will run a gRPC function call, get the block and update the local state."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"}," Check if the node is a validator after syncing the latest block "),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If it is, jump out of sync state"),(0,o.kt)("li",{parentName:"ul"},"If it is not, continue listening for new block events")))),(0,o.kt)("h2",{id:"performance-report"},"Performance report"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Performance was measured on a local machine by syncing a ",(0,o.kt)("strong",{parentName:"p"}," million blocks "))),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Name"),(0,o.kt)("th",{parentName:"tr",align:null},"Result"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Syncing 1M blocks"),(0,o.kt)("td",{parentName:"tr",align:null},"~ 25 min")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Tranfering 1M blocks"),(0,o.kt)("td",{parentName:"tr",align:null},"~ 1 min")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Number of GRPC calls"),(0,o.kt)("td",{parentName:"tr",align:null},"2")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Test coverage"),(0,o.kt)("td",{parentName:"tr",align:null},"~ 93%")))))}m.isMDXComponent=!0}}]);