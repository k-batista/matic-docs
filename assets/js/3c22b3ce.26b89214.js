"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[26381],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return d}});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),m=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=m(e.components);return o.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),h=m(n),d=r,u=h["".concat(s,".").concat(d)]||h[d]||p[d]||i;return n?o.createElement(u,a(a({ref:t},l),{},{components:n})):o.createElement(u,a({ref:t},l))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,a[1]=c;for(var m=2;m<i;m++)a[m]=n[m];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},59651:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return c},metadata:function(){return m},toc:function(){return p}});var o=n(87462),r=n(63366),i=(n(67294),n(3905)),a=["components"],c={id:"checkpoint-mechanism",title:"Checkpoint Mechanism",sidebar_label:"Checkpoints",description:"Checkpointing the system state to the Ethereum mainnet",keywords:["docs","matic","polygon","checkpoint","ethereum","mainnet"],slug:"checkpoint-mechanism",image:"https://wiki.polygon.technology/img/polygon-logo.png"},s=void 0,m={unversionedId:"maintain/validator/core-components/checkpoint-mechanism",id:"maintain/validator/core-components/checkpoint-mechanism",title:"Checkpoint Mechanism",description:"Checkpointing the system state to the Ethereum mainnet",source:"@site/docs/maintain/validator/core-components/checkpoint-mechanism.md",sourceDirName:"maintain/validator/core-components",slug:"/maintain/validator/core-components/checkpoint-mechanism",permalink:"/matic-docs/docs/maintain/validator/core-components/checkpoint-mechanism",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/maintain/validator/core-components/checkpoint-mechanism.md",tags:[],version:"current",lastUpdatedBy:"Kennedy Batista",lastUpdatedAt:1686621530,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"checkpoint-mechanism",title:"Checkpoint Mechanism",sidebar_label:"Checkpoints",description:"Checkpointing the system state to the Ethereum mainnet",keywords:["docs","matic","polygon","checkpoint","ethereum","mainnet"],slug:"checkpoint-mechanism",image:"https://wiki.polygon.technology/img/polygon-logo.png"},sidebar:"maintain",previous:{title:"Bor Chain",permalink:"/matic-docs/docs/maintain/validator/core-components/bor-chain"},next:{title:"Key Management",permalink:"/matic-docs/docs/maintain/validator/core-components/key-management"}},l={},p=[],h={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,a);return(0,i.kt)("wrapper",(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{title:"Polygon is not a Layer 1 platform",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Polygon depends on the Ethereum Mainnet as its Layer 1 Settlement Layer. All staking mechanics need to be in sync with the contracts on the Ethereum mainnet.")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/matic-docs/docs/maintain/glossary#proposer"},"Proposers")," for a checkpoint are initially selected via ",(0,i.kt)("a",{parentName:"p",href:"https://docs.tendermint.com/master/spec/consensus/proposer-selection.html"},"Tendermint\u2019s weighted round-robin algorithm"),". A further custom check is implemented based on the checkpoint submission success. This allows the Polygon system to decouple with Tendermint proposer selection and provides Polygon with the abilities like selecting a proposer only when the checkpoint transaction on the Ethereum mainnet succeeds or submitting a checkpoint transaction for the blocks belonging to previous failed checkpoints."),(0,i.kt)("p",null,"Successfully submitting a checkpoint on Tendermint is a 2-phase commit process:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A proposer, selected via the round-robin algorithm, sends a checkpoint with the proposer's address and the Merkle hash in the proposer field."),(0,i.kt)("li",{parentName:"ul"},"All other proposers validate the data in the proposer field before adding the Merkle hash in their state.")),(0,i.kt)("p",null,"The next proposer then sends an acknowledgment transaction to prove that the previous ",(0,i.kt)("a",{parentName:"p",href:"/matic-docs/docs/maintain/glossary#checkpoint-transaction"},"checkpoint transaction")," has succeeded on the Ethereum mainnet. Every validator set change is relayed by the validator nodes on ",(0,i.kt)("a",{parentName:"p",href:"/matic-docs/docs/maintain/glossary#heimdall"},"Heimdall")," which is embedded onto the validator node. This allows Heimdall to remain in sync with the Polygon contract state on the Ethereum mainnet at all times."),(0,i.kt)("p",null,"The Polygon contract deployed on the Ethereum mainnet is considered to be the ultimate source of truth, and therefore all validation is done via querying the Ethereum mainnet contract."))}d.isMDXComponent=!0}}]);