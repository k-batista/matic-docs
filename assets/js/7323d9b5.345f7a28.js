"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[39714],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,k=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return n?a.createElement(k,i(i({ref:t},p),{},{components:n})):a.createElement(k,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},67027:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var a=n(87462),o=n(63366),r=(n(67294),n(3905)),i=["components"],s={id:"erc721",title:"ER721 Deposit and Withdraw Guide",sidebar_label:"ERC721",description:"Available functions for ERC721 contracts.",keywords:["docs","matic","erc721","deposit","withdraw"],image:"https://matic.network/banners/matic-network-16x9.png"},l=void 0,c={unversionedId:"develop/ethereum-polygon/pos/calling-contracts/erc721",id:"develop/ethereum-polygon/pos/calling-contracts/erc721",title:"ER721 Deposit and Withdraw Guide",description:"Available functions for ERC721 contracts.",source:"@site/docs/develop/ethereum-polygon/pos/calling-contracts/erc721.md",sourceDirName:"develop/ethereum-polygon/pos/calling-contracts",slug:"/develop/ethereum-polygon/pos/calling-contracts/erc721",permalink:"/matic-docs/docs/develop/ethereum-polygon/pos/calling-contracts/erc721",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/develop/ethereum-polygon/pos/calling-contracts/erc721.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686624865,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"erc721",title:"ER721 Deposit and Withdraw Guide",sidebar_label:"ERC721",description:"Available functions for ERC721 contracts.",keywords:["docs","matic","erc721","deposit","withdraw"],image:"https://matic.network/banners/matic-network-16x9.png"}},p={},d=[{value:"High Level Flow",id:"high-level-flow",level:2},{value:"Step Details",id:"step-details",level:2},{value:"Instantiate the contracts",id:"instantiate-the-contracts",level:3},{value:"Approve",id:"approve",level:3},{value:"Deposit",id:"deposit",level:3},{value:"Burn",id:"burn",level:3},{value:"Exit",id:"exit",level:3}],u={toc:d};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"high-level-flow"},"High Level Flow"),(0,r.kt)("p",null,"Depositing ERC721 -"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"Approve"))," ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"ERC721Predicate"))," contract to spend the tokens that have to be deposited."),(0,r.kt)("li",{parentName:"ol"},"Make ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"depositFor"))," call on ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"RootChainManager")),".")),(0,r.kt)("p",null,"Withdrawing ERC721 -"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"Burn"))," tokens on Polygon chain."),(0,r.kt)("li",{parentName:"ol"},"Call ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"exit"))," function on ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"RootChainManager"))," to submit proof of burn transaction. This call can be made ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"after checkpoint"))," is submitted for the block containing burn transaction.")),(0,r.kt)("h2",{id:"step-details"},"Step Details"),(0,r.kt)("h3",{id:"instantiate-the-contracts"},"Instantiate the contracts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const mainWeb3 = new Web3(mainProvider)\nconst maticWeb3 = new Web3(maticProvider)\nconst rootTokenContract = new mainWeb3.eth.Contract(rootTokenABI, rootTokenAddress)\nconst rootChainManagerContract = new mainWeb3.eth.Contract(rootChainManagerABI, rootChainManagerAddress)\nconst childTokenContract = new maticWeb3(childTokenABI, childTokenAddress)\n")),(0,r.kt)("h3",{id:"approve"},"Approve"),(0,r.kt)("p",null,"Approve ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ERC721Predicate"))," to spend tokens by calling the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"approve"))," function of token contract. This function takes two arguments spender and tokenId. ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"spender"))," is the address that is being approval to spend user's tokens. ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"tokenId"))," is the id of token that can be spent. You can also call the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"setApprovalForAll"))," function if you want to do multiple deposits."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await rootTokenContract.methods\n  .approve(erc721Predicate, tokenId)\n  .send({ from: userAddress })\n")),(0,r.kt)("h3",{id:"deposit"},"Deposit"),(0,r.kt)("p",null,"Note that the token needs to be mapped and ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenId")," has to be approved for a deposit before making this call.",(0,r.kt)("br",{parentName:"p"}),"\n","Call the ",(0,r.kt)("inlineCode",{parentName:"p"},"depositFor()")," function of ",(0,r.kt)("inlineCode",{parentName:"p"},"RootChainManager")," contract. This function takes 3 arguments: ",(0,r.kt)("inlineCode",{parentName:"p"},"userAddress"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"rootToken"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"depositData"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"userAddress")," is the address of the user that will receive the deposit on the Polygon chain. ",(0,r.kt)("inlineCode",{parentName:"p"},"rootToken")," is the address of the token on main chain. ",(0,r.kt)("inlineCode",{parentName:"p"},"depositData")," is the abi-encoded ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenId"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const depositData = mainWeb3.eth.abi.encodeParameter('uint256', tokenId)\nawait rootChainManagerContract.methods\n  .depositFor(userAddress, rootToken, depositData)\n  .send({ from: userAddress })\n")),(0,r.kt)("h3",{id:"burn"},"Burn"),(0,r.kt)("p",null,"Tokens can be burned on the Polygon chain by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"withdraw")," function on the child token contract. This function takes a single argument, ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenId")," indicating the token to be burned. Proof of this burn needs to be submitted in the exit step. So store the transaction hash."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const burnTx = await childTokenContract.methods\n  .withdraw(tokenId)\n  .send({ from: userAddress })\nconst burnTxHash = burnTx.transactionHash\n")),(0,r.kt)("h3",{id:"exit"},"Exit"),(0,r.kt)("p",null,"Completing the cycle means calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"exit")," function on the ",(0,r.kt)("inlineCode",{parentName:"p"},"RootChainManager")," contract which unlocks and receives the tokens back from the ",(0,r.kt)("inlineCode",{parentName:"p"},"ERC721Predicate"),". This function takes a single-byte argument from the ",(0,r.kt)("inlineCode",{parentName:"p"},"withdraw")," function and uses it as proof of burn for the transaction. It's important that we wait for the checkpoint containing the burn transaction to be submitted before calling this function. The proof of burn is generated by RLP-encoding the following fields:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"headerNumber - Checkpoint header block number containing the burn transaction"),(0,r.kt)("li",{parentName:"ul"},"blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root"),(0,r.kt)("li",{parentName:"ul"},"blockNumber - Block number containing the burn transaction on child chain"),(0,r.kt)("li",{parentName:"ul"},"blockTime - Burn transaction block time"),(0,r.kt)("li",{parentName:"ul"},"txRoot - Transactions root of block"),(0,r.kt)("li",{parentName:"ul"},"receiptRoot - Receipts root of block"),(0,r.kt)("li",{parentName:"ul"},"receipt - Receipt of the burn transaction"),(0,r.kt)("li",{parentName:"ul"},"receiptProof - Merkle proof of the burn receipt"),(0,r.kt)("li",{parentName:"ul"},"branchMask - 32 bits denoting the path of receipt in merkle patricia tree"),(0,r.kt)("li",{parentName:"ul"},"receiptLogIndex - Log Index to read from the receipt")),(0,r.kt)("p",null,"Generating all this information manually has historically proven to be tricky, so we advise you use the matic.js SDK. If you're still interested in sending the transaction manually, please pass encodeAbi as true in the options object to get raw call data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const exitCalldata = await maticPOSClient\n  .exitERC721(burnTxHash, { from, encodeAbi: true })\n")),(0,r.kt)("p",null,"Send this calldata to ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"RootChainManager")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await mainWeb3.eth.sendTransaction({\n  from: userAddress,\n  to: rootChainManagerAddress,\n  data: exitCalldata.data\n})\n")))}m.isMDXComponent=!0}}]);