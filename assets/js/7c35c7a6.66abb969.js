"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[73487],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return m}});var o=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,o,r=function(e,t){if(null==e)return{};var a,o,r={},n=Object.keys(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=o.createContext({}),c=function(e){var t=o.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var a=e.components,r=e.mdxType,n=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(a),m=r,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||n;return a?o.createElement(h,i(i({ref:t},p),{},{components:a})):o.createElement(h,i({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=a.length,i=new Array(n);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<n;c++)i[c]=a[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}u.displayName="MDXCreateElement"},29636:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return u}});var o=a(87462),r=a(63366),n=(a(67294),a(3905)),i=a(44996),l=["components"],s={id:"bor",title:"Bor Architecture",description:"The Bor role in the Polygon architecture",keywords:["docs","matic","Bor Architecture","polygon"],image:"https://matic.network/banners/matic-network-16x9.png"},c="Bor Architecture",p={unversionedId:"pos/bor/bor",id:"pos/bor/bor",title:"Bor Architecture",description:"The Bor role in the Polygon architecture",source:"@site/docs/pos/bor/bor.md",sourceDirName:"pos/bor",slug:"/pos/bor/",permalink:"/matic-docs/docs/pos/bor/",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/pos/bor/bor.md",tags:[],version:"current",lastUpdatedBy:"Kennedy Batista",lastUpdatedAt:1686621530,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"bor",title:"Bor Architecture",description:"The Bor role in the Polygon architecture",keywords:["docs","matic","Bor Architecture","polygon"],image:"https://matic.network/banners/matic-network-16x9.png"},sidebar:"pos",previous:{title:"Overview",permalink:"/matic-docs/docs/pos/bor/overview"},next:{title:"Core Concepts",permalink:"/matic-docs/docs/pos/bor/core_concepts"}},d={},u=[{value:"Architecture",id:"architecture",level:2},{value:"Heimdall (Validator layer)",id:"heimdall-validator-layer",level:2},{value:"Bor (Block Producer layer)",id:"bor-block-producer-layer",level:2},{value:"Polygon Chain",id:"polygon-chain",level:3},{value:"EVM Compatible VM",id:"evm-compatible-vm",level:3},{value:"Proposers and Producers Selection",id:"proposers-and-producers-selection",level:3},{value:"Selection Process",id:"selection-process",level:4},{value:"SystemCall Interface",id:"systemcall-interface",level:3},{value:"Functions",id:"functions",level:3},{value:"proposeState",id:"proposestate",level:4},{value:"commitState",id:"commitstate",level:4},{value:"proposeSpan",id:"proposespan",level:4},{value:"proposeCommit",id:"proposecommit",level:4},{value:"Bor Fee Model",id:"bor-fee-model",level:3},{value:"Technical Insight",id:"technical-insight",level:2},{value:"Genesis Contracts",id:"genesis-contracts",level:3},{value:"Bor.go",id:"borgo",level:3},{value:"Glossary",id:"glossary",level:2},{value:"Resources",id:"resources",level:2}],m={toc:u};function h(e){var t=e.components,a=(0,r.Z)(e,l);return(0,n.kt)("wrapper",(0,o.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"bor-architecture"},"Bor Architecture"),(0,n.kt)("p",null,"Polygon is a hybrid ",(0,n.kt)("strong",{parentName:"p"},"Plasma + Proof-of-Stake (PoS)")," platform. We use a dual-consensus architecture on the Polygon Network to optimise for speed and decentralisation. We consciously architected the system to support arbitrary state transitions on our sidechains, which are EVM-enabled."),(0,n.kt)("h2",{id:"architecture"},"Architecture"),(0,n.kt)("img",{src:(0,i.Z)("img/Bor/matic_structure.png")}),(0,n.kt)("p",null,"A blockchain is a set of network clients interacting and working together. The client is a piece of software capable of establishing a p2p communication channel with other clients, signing and broadcasting transactions, deploying and interacting with smart contracts, etc. The client is often referred to as a node."),(0,n.kt)("p",null,"For Polygon, the node is designed with a two layer implementation Heimdall (Validator Layer) and Bor(Block Producer Layer)."),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Heimdall",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Proof-of-Stake verification"),(0,n.kt)("li",{parentName:"ul"},"Checkpointing blocks on Ethereum main chain"),(0,n.kt)("li",{parentName:"ul"},"Validator and Rewards Management"),(0,n.kt)("li",{parentName:"ul"},"Ensuring Sync with Ethereum main chain"),(0,n.kt)("li",{parentName:"ul"},"Decentralised Bridge"))),(0,n.kt)("li",{parentName:"ol"},"Bor",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Polygon Chain"),(0,n.kt)("li",{parentName:"ul"},"EVM Compatible VM"),(0,n.kt)("li",{parentName:"ul"},"Proposers and Producer set selection"),(0,n.kt)("li",{parentName:"ul"},"SystemCall"),(0,n.kt)("li",{parentName:"ul"},"Fee Model")))),(0,n.kt)("h2",{id:"heimdall-validator-layer"},"Heimdall (Validator layer)"),(0,n.kt)("p",null,"Heimdall (the All-Protector) is the purveyor of all that happens in the Polygon Proof-of-Stake system \u2013 good or bad."),(0,n.kt)("p",null,"Heimdall is our Proof-of-Stake Verifier layer, which is responsible for checkpointing a representation of the Plasma blocks to the main chain in our architecture. We have implemented this by building on top of the Tendermint consensus engine with changes to the signature scheme and various data structures."),(0,n.kt)("p",null,"For more information, please read ",(0,n.kt)("a",{parentName:"p",href:"https://blog.matic.network/heimdall-and-bor-matic-validator-and-block-production-layers/"},"https://blog.matic.network/heimdall-and-bor-matic-validator-and-block-production-layers/"),"."),(0,n.kt)("h2",{id:"bor-block-producer-layer"},"Bor (Block Producer layer)"),(0,n.kt)("p",null,"The Bor node implementation is basically the sidechain operator. The sidechain VM is EVM-compatible. Currently, it is a basic Geth implementation with custom changes done to the consensus algorithm. However, this will be built from the ground up to make it lightweight and focused."),(0,n.kt)("p",null,"Bor is our Block producer layer, which in sync with Heimdall selects the producers and verifiers for each span and sprint. Interaction for the users of Polygon take place on this sidechain, which is EVM compatible to avail the functionality and compatibility of Ethereum developer tooling and applications. "),(0,n.kt)("h3",{id:"polygon-chain"},"Polygon Chain"),(0,n.kt)("p",null,"This chain is a separate blockchain that is attached to Ethereum using a two-way peg. The two-way peg enables interchangeability of assets between the Ethereum and Polygon."),(0,n.kt)("h3",{id:"evm-compatible-vm"},"EVM Compatible VM"),(0,n.kt)("p",null,"The Ethereum Virtual Machine (EVM) is a powerful, sandboxed virtual stack embedded within each full Polygon node, responsible for executing contract bytecode. Contracts are typically written in higher level languages, like Solidity, then compiled to EVM bytecode."),(0,n.kt)("h3",{id:"proposers-and-producers-selection"},"Proposers and Producers Selection"),(0,n.kt)("p",null,"Block Producers for the Bor layer are a committee selected from the Validator pool on the basis of their stake, which happens at regular intervals and is shuffled periodically. These intervals are decided by the Validator's governance with regards to dynasty and network."),(0,n.kt)("p",null,"Ratio of Stake/Staking power specifies the probability to be selected as a member of the block producer committee. "),(0,n.kt)("img",{src:(0,i.Z)("img/Bor/bor-span.png")}),(0,n.kt)("h4",{id:"selection-process"},"Selection Process"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Let's suppose we have 3 validators in pool, and they are Alice, Bill and Clara."),(0,n.kt)("li",{parentName:"ul"},"Alice staked 100 Matic tokens whereas Bill and Clara staked 40 Matic tokens."),(0,n.kt)("li",{parentName:"ul"},"Validators are given slots according to the stake, as Alice has 100 Matic tokens staked, she will get slots proportionally. Alice will get 5 slots in total. Similarly, Bill and Clara get 2 slots in total."),(0,n.kt)("li",{parentName:"ul"},"All the validators are given these slots ","[ A, A, A, A, A, B, B, C, C ]"),(0,n.kt)("li",{parentName:"ul"},"Using historical Ethereum block data as seed, we shuffle this array."),(0,n.kt)("li",{parentName:"ul"},"After shuffling the slots using the seed, say we get this array ","[ A, B, A, A, C, B, A, A, C]"),(0,n.kt)("li",{parentName:"ul"},"Now depending on Producer count",(0,n.kt)("em",{parentName:"li"},"(maintained by validator's governance)"),", we pop validators from the top. For e.g. if we want to select 5 producers we get the producer set as ","[ A, B, A, A, C]"),(0,n.kt)("li",{parentName:"ul"},"Hence the producer set for the next span is defined as ","[ A: 3, B:1, C:1 ]","."),(0,n.kt)("li",{parentName:"ul"},"Using this validator set and tendermint's proposer selection algorithm we choose a producer for every sprint on BOR.")),(0,n.kt)("h3",{id:"systemcall-interface"},"SystemCall Interface"),(0,n.kt)("p",null,"System call is an internal operator address which is under EVM. This helps to maintain the state for Block Producers for every sprint. A System Call is triggered towards the end of a sprint and a request is made for the new list of Block Producers. Once the state is updated, changes are received after block generation on Bor to all the Validators."),(0,n.kt)("h3",{id:"functions"},"Functions"),(0,n.kt)("h4",{id:"proposestate"},"proposeState"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Call is only allowed to validators."),(0,n.kt)("li",{parentName:"ul"},"Inspect ",(0,n.kt)("inlineCode",{parentName:"li"},"stateId")," if it is already proposed or committed."),(0,n.kt)("li",{parentName:"ul"},"Propose the ",(0,n.kt)("inlineCode",{parentName:"li"},"stateId")," and update the flag to ",(0,n.kt)("inlineCode",{parentName:"li"},"true"),".")),(0,n.kt)("h4",{id:"commitstate"},"commitState"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Call is only allowed to System."),(0,n.kt)("li",{parentName:"ul"},"Inspect ",(0,n.kt)("inlineCode",{parentName:"li"},"stateId")," if it is already proposed or committed."),(0,n.kt)("li",{parentName:"ul"},"Notify ",(0,n.kt)("inlineCode",{parentName:"li"},"StateReceiver")," Contract with new ",(0,n.kt)("inlineCode",{parentName:"li"},"stateId"),"."),(0,n.kt)("li",{parentName:"ul"},"Update the ",(0,n.kt)("inlineCode",{parentName:"li"},"state")," flag to ",(0,n.kt)("inlineCode",{parentName:"li"},"true"),", And ",(0,n.kt)("inlineCode",{parentName:"li"},"remove")," the ",(0,n.kt)("inlineCode",{parentName:"li"},"proposedState"),".")),(0,n.kt)("h4",{id:"proposespan"},"proposeSpan"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Call is only allowed to validators."),(0,n.kt)("li",{parentName:"ul"},"Check if the Span proposal is ",(0,n.kt)("inlineCode",{parentName:"li"},"pending"),"."),(0,n.kt)("li",{parentName:"ul"},"Update the Span Proposal to ",(0,n.kt)("inlineCode",{parentName:"li"},"true"))),(0,n.kt)("h4",{id:"proposecommit"},"proposeCommit"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Call is only allowed to System."),(0,n.kt)("li",{parentName:"ul"},"Set ",(0,n.kt)("inlineCode",{parentName:"li"},"initial validators")," if current span is zero."),(0,n.kt)("li",{parentName:"ul"},"Check Conditions for ",(0,n.kt)("inlineCode",{parentName:"li"},"spanId")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"time_period")," of Sprint and Span."),(0,n.kt)("li",{parentName:"ul"},"Update the new ",(0,n.kt)("inlineCode",{parentName:"li"},"span")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"time_period"),"."),(0,n.kt)("li",{parentName:"ul"},"Set ",(0,n.kt)("inlineCode",{parentName:"li"},"validators")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"blockProducers")," for the ",(0,n.kt)("inlineCode",{parentName:"li"},"sprint"),"."),(0,n.kt)("li",{parentName:"ul"},"Update the flag for ",(0,n.kt)("inlineCode",{parentName:"li"},"spanProposal")," to ",(0,n.kt)("inlineCode",{parentName:"li"},"true"),".")),(0,n.kt)("h3",{id:"bor-fee-model"},"Bor Fee Model"),(0,n.kt)("p",null,"For normal transaction, fees in Matic token gets collected and distributed to block producers, similar to Ethereum transactions. "),(0,n.kt)("p",null,"Like other blockchains, Polygon has a native token called Matic(MATIC). MATIC is an ERC20 token used primarily for paying gas(transaction fees) on Polygon and staking. "),(0,n.kt)("admonition",{type:"info"},(0,n.kt)("p",{parentName:"admonition"},"An important thing to note is that on the Polygon chain, the MATIC tokens works as an ERC20 token, but also as the native token - both at the same time. Therefore, this means that a user can pay gas with MATIC as well as send MATIC to other accounts.")),(0,n.kt)("p",null,"For genesis-contracts, ",(0,n.kt)("inlineCode",{parentName:"p"},"gasPrice")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"gasLimit")," works same as Ethereum, but during the execution it won't deduct the fees from sender's account."),(0,n.kt)("p",null,"Genesis transactions from current validators are executed with ",(0,n.kt)("inlineCode",{parentName:"p"},"gasPrice = 0"),". "),(0,n.kt)("p",null,"Also, validators have to send following types of transaction like State proposals like deposits & Span proposals on Bor."),(0,n.kt)("h2",{id:"technical-insight"},"Technical Insight"),(0,n.kt)("h3",{id:"genesis-contracts"},"Genesis Contracts"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/genesis-contracts/blob/master/contracts/BorValidatorSet.template"},"BorValidatorSet(0x1000)")," \u21d2 This contract manages validator set for each span and sprint."),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/genesis-contracts/blob/master/contracts/StateReceiver.sol"},"BorStateReceiver(0x1001)")," \u21d2 This Contract manages the transfer of arbitrary contract data from Ethereum contracts to Polygon contracts"),(0,n.kt)("p",null,"MaticChildERC20(0x1010) \u21d2 Child Contract for Main Chain tokens which allows to move assets from Ethereum to Polygon."),(0,n.kt)("h3",{id:"borgo"},(0,n.kt)("a",{parentName:"h3",href:"https://github.com/maticnetwork/bor/blob/master/consensus/bor/bor.go"},"Bor.go")),(0,n.kt)("p",null,"Bor Protocol"),(0,n.kt)("h2",{id:"glossary"},"Glossary"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"StartEpoch - Checkpoint number post which a validator is activated and will participate in the consensus."),(0,n.kt)("li",{parentName:"ul"},"EndEpoch - Checkpoint number post which a validator is considered deactivated and won't participate in the consensus."),(0,n.kt)("li",{parentName:"ul"},"Sprint - Sprint is a continuous set of blocks created by a single validator."),(0,n.kt)("li",{parentName:"ul"},"Span -  Span is a big set of blocks with a fixed validator set but consisting of various sprints. For eg for a span of length 1600 blocks it will consist of 100 sprints of 16 blocks."),(0,n.kt)("li",{parentName:"ul"},"Dynasty: Time between the end of last auction and start time of next auction.")),(0,n.kt)("h2",{id:"resources"},"Resources"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/maticnetwork/bor"},"Bor")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.bitrates.com/guides/ethereum/what-is-the-unstoppable-world-computer"},"EVM")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://medium.com/mycrypto/the-ethereum-virtual-machine-how-does-it-work-9abac2b7c9e"},"How EVM Works?")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://docs.tendermint.com/master/spec/reactors/consensus/proposer-selection.html"},"Tendermint Proposer Selection"))))}h.isMDXComponent=!0}}]);