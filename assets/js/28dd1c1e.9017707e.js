"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[86828],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return m}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),p=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),h=p(n),m=i,d=h["".concat(c,".").concat(m)]||h[m]||u[m]||r;return n?a.createElement(d,o(o({ref:t},s),{},{components:n})):a.createElement(d,o({ref:t},s))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},79455:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var a=n(87462),i=n(63366),r=(n(67294),n(3905)),o=["components"],l={id:"checkpoint-manager",title:"CheckpointManager",description:"The Checkpoint Manager contract for Polygon Edge",keywords:["docs","polygon","edge","core","checkpoint","manager"]},c=void 0,p={unversionedId:"supernets/contracts/checkpoint-manager",id:"supernets/contracts/checkpoint-manager",title:"CheckpointManager",description:"The Checkpoint Manager contract for Polygon Edge",source:"@site/docs/supernets/contracts/checkpoint-manager.md",sourceDirName:"supernets/contracts",slug:"/supernets/contracts/checkpoint-manager",permalink:"/matic-docs/docs/supernets/contracts/checkpoint-manager",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/supernets/contracts/checkpoint-manager.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686625626,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"checkpoint-manager",title:"CheckpointManager",description:"The Checkpoint Manager contract for Polygon Edge",keywords:["docs","polygon","edge","core","checkpoint","manager"]}},s={},u=[{value:"Overview",id:"overview",level:2},{value:"Functions",id:"functions",level:2},{value:"initialize",id:"initialize",level:3},{value:"submit",id:"submit",level:3},{value:"getEventMembershipByBlockNumber",id:"geteventmembershipbyblocknumber",level:3},{value:"getEventMembershipByEpoch",id:"geteventmembershipbyepoch",level:3},{value:"getEventRootByBlock",id:"geteventrootbyblock",level:3},{value:"_setNewValidatorSet",id:"_setnewvalidatorset",level:3},{value:"_verifySignature",id:"_verifysignature",level:3},{value:"verifyCheckpoint",id:"verifycheckpoint",level:3},{value:"_getValueFromBitmap",id:"_getvaluefrombitmap",level:3}],h={toc:u};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"The CheckpointManager contract is used by validators to submit signed\ncheckpoints as proof of the canonical chain. The contract verifies that the\nprovided signature is valid and that the checkpoint has been signed as expected.\nThe contract also includes an initialization function that can only be\ncalled once to set the contract's dependencies and domain."),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("h3",{id:"initialize"},"initialize"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function initialize(\n    IBLS newBls,\n    IBN256G2 newBn256G2,\n    bytes32 newDomain,\n    uint256 chainId_,\n    Validator[] calldata newValidatorSet\n ) external initializer {\n    // Implementation details ...\n}\n")),(0,r.kt)("p",null,"This function is the initializer for the CheckpointManager contract.\nIt sets the following contract dependencies and parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"newBls"),": The address of the BLS library contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"newBn256G2"),": The address of the BN256G2 library contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"newDomain"),": The domain to use when hashing messages to a point."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"chainId_"),": The chain ID of the Ethereum network."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"newValidatorSet"),": The array of validators to seed the contract with.\nThis is passed as calldata so that the contract doesn't have to be initialized\nwith a static length.")),(0,r.kt)("h3",{id:"submit"},"submit"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"  function submit(\n    CheckpointMetadata calldata checkpointMetadata,\n    Checkpoint calldata checkpoint,\n    uint256[2] calldata signature,\n    Validator[] calldata newValidatorSet,\n    bytes calldata bitmap\n  ) external {\n      // Implementation details ...\n}\n")),(0,r.kt)("p",null,"This function is used by validators to submit a new checkpoint."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"checkpointMetadata"),": Contains metadata about the submitted checkpoint,\nsuch as the current validator set hash and block hash."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"checkpoint"),": The checkpoint data, including the block number, epoch, event\nroot, and nonce."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signature"),": The signature from a group of validators, verifying the submitted\ncheckpoint data."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"newValidatorSet"),": An array of updated validators for the contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bitmap"),": The bitmap of the signatures, indicating which validators signed the\ncheckpoint.")),(0,r.kt)("h3",{id:"geteventmembershipbyblocknumber"},"getEventMembershipByBlockNumber"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function getEventMembershipByBlockNumber(\n      uint256 blockNumber,\n      bytes32 leaf,\n      uint256 leafIndex,\n      bytes32[] calldata proof\n  ) external view returns (bool) {\n    // Implementation details ...\n  }\n")),(0,r.kt)("p",null,"This function returns a boolean indicating whether the specified leaf is\na member of the event root corresponding to the given blockNumber."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"blockNumber"),": The block number to retrieve the event root for."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"leaf"),": The leaf to check membership for."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"leafIndex"),": The index of the leaf in the Merkle tree."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"proof"),": The Merkle proof demonstrating membership of the leaf in the\nMerkle tree.")),(0,r.kt)("h3",{id:"geteventmembershipbyepoch"},"getEventMembershipByEpoch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function getEventMembershipByEpoch(\n      uint256 epoch,\n      bytes32 leaf,\n      uint256 leafIndex,\n      bytes32[] calldata proof\n  ) external view returns (bool) {\n    // Implementation details ...\n  }\n")),(0,r.kt)("p",null,"This function returns the membership status of an event (specified by\n",(0,r.kt)("inlineCode",{parentName:"p"},"leaf")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"leafIndex"),") in an event merkle tree (specified by ",(0,r.kt)("inlineCode",{parentName:"p"},"eventRoot"),")\nduring a certain epoch of the Ethereum network."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"epoch"),": The epoch for which to check event membership."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"leaf"),": The 32-byte hash of the event."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"leafIndex"),": The position of the event in the event merkle tree."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"proof"),": The merkle proof to validate the membership of the event in the\ntree."),(0,r.kt)("li",{parentName:"ul"},"The function returns true if the event is a member of the tree, and false\notherwise.")),(0,r.kt)("h3",{id:"geteventrootbyblock"},"getEventRootByBlock"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"  function getEventRootByBlock(uint256 blockNumber) external view returns (bytes32 root) {\n      // Implementation details ...\n  }\n")),(0,r.kt)("p",null,"This function returns the Merkle root of the event log for a specific block number."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"blockNumber"),": The number of the block for which to retrieve the checkpoint Merkle\ntree root."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"root"),": The root of the Merkle tree of checkpoints for the specified block.")),(0,r.kt)("h3",{id:"_setnewvalidatorset"},"_setNewValidatorSet"),(0,r.kt)("admonition",{title:"Current validator set",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"To bootstrap the network, the root validator is composed of internal\nvalidators of Polygon Labs.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function _setNewValidatorSet(Validator[] calldata newValidatorSet) private {\n    // Implementation details ...\n  }\n")),(0,r.kt)("p",null,"This is an internal function used to set a new validator set for the contract."),(0,r.kt)("h3",{id:"_verifysignature"},"_verifySignature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function _verifySignature(\n        uint256[2] memory message,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    ) private view {\n    // Implementation details ...\n  }\n")),(0,r.kt)("p",null,"This function checks the validity of a checkpoint by verifying the signature\nincluded in the checkpoint against a computed aggregate public key of the validators\nand a message (both passed as inputs)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"message"),": A 2-element array representing the message to verify.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"signature"),": A 2-element array representing the signature to verify against the\nmessage and aggregate public key.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bitmap"),": A byte array representing the bitmap indicating which validators were\ninvolved in signing the message.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The function performs the following checks and throws an error if any check fails:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Bitmap is not empty"),(0,r.kt)("li",{parentName:"ul"},"Total voting power represented by validators in the bitmap is greater than 2/3 of\nthe total voting power of all validators"),(0,r.kt)("li",{parentName:"ul"},"The signature is successfully verified against the message and aggregate public key.")))),(0,r.kt)("h3",{id:"verifycheckpoint"},"verifyCheckpoint"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function _verifyCheckpoint(uint256 prevId, Checkpoint calldata checkpoint) private view {\n    Checkpoint memory oldCheckpoint = checkpoints[prevId];\n    require(\n    // Implementation details ...\n    );\n}\n")),(0,r.kt)("p",null,"This function verifies a checkpoint by checking its validity."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"prevId"),": The ID of the current checkpoint."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"checkpoint"),": The checkpoint to be verified.")),(0,r.kt)("p",null,"The function checks if the checkpoint has a valid epoch value, either equal to the\nepoch value of the current checkpoint or one greater than it. It also checks if the\n",(0,r.kt)("inlineCode",{parentName:"p"},"blockNumber")," of the checkpoint is greater than the ",(0,r.kt)("inlineCode",{parentName:"p"},"blockNumber")," of the current checkpoint.\nIf both checks pass, the function returns true, otherwise it throws an error."),(0,r.kt)("h3",{id:"_getvaluefrombitmap"},"_getValueFromBitmap"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function _getValueFromBitmap(bytes calldata bitmap, uint256 index) private pure returns (bool) {\n    // Implementation details ...\n}\n")),(0,r.kt)("p",null,"This is an internal function which takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"bitmap")," and an ",(0,r.kt)("inlineCode",{parentName:"p"},"index")," as\ninputs and returns a boolean value. It works as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"byteNumber")," is calculated as index / 8"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bitNumber")," is calculated as index % 8"),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"byteNumber")," is greater than or equal to the length of ",(0,r.kt)("inlineCode",{parentName:"li"},"bitmap"),", it returns false."),(0,r.kt)("li",{parentName:"ul"},"It returns the result of the expression uint8(bitmap","[byteNumber]",") & (1 << ",(0,r.kt)("inlineCode",{parentName:"li"},"bitNumber"),") > 0,\nwhich checks if the bitNumber-th bit of the byteNumber-th byte in bitmap is set to 1.")))}m.isMDXComponent=!0}}]);