"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[39536],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),u=r,k=m["".concat(l,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(k,i(i({ref:t},p),{},{components:n})):a.createElement(k,i({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},30339:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var a=n(87462),r=n(63366),o=(n(67294),n(3905)),i=["components"],s={id:"erc1155",title:"ER1155 Deposit and Withdraw Guide",sidebar_label:"ERC1155",description:"Available functions for ERC1155 contracts.",keywords:["docs","matic","erc1155","deposit","withdraw"],image:"https://matic.network/banners/matic-network-16x9.png"},l=void 0,c={unversionedId:"develop/ethereum-polygon/pos/calling-contracts/erc1155",id:"develop/ethereum-polygon/pos/calling-contracts/erc1155",title:"ER1155 Deposit and Withdraw Guide",description:"Available functions for ERC1155 contracts.",source:"@site/docs/develop/ethereum-polygon/pos/calling-contracts/erc1155.md",sourceDirName:"develop/ethereum-polygon/pos/calling-contracts",slug:"/develop/ethereum-polygon/pos/calling-contracts/erc1155",permalink:"/matic-docs/docs/develop/ethereum-polygon/pos/calling-contracts/erc1155",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/develop/ethereum-polygon/pos/calling-contracts/erc1155.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686626387,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"erc1155",title:"ER1155 Deposit and Withdraw Guide",sidebar_label:"ERC1155",description:"Available functions for ERC1155 contracts.",keywords:["docs","matic","erc1155","deposit","withdraw"],image:"https://matic.network/banners/matic-network-16x9.png"}},p={},d=[{value:"High Level Flow",id:"high-level-flow",level:2},{value:"Step Details",id:"step-details",level:2},{value:"Instantiate the contracts",id:"instantiate-the-contracts",level:3},{value:"Approve",id:"approve",level:3},{value:"Deposit",id:"deposit",level:3},{value:"Burn",id:"burn",level:3},{value:"Exit",id:"exit",level:3}],m={toc:d};function u(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"high-level-flow"},"High Level Flow"),(0,o.kt)("p",null,"Depositing ERC1155 -"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"Approve"))," ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"ERC1155Predicate"))," contract to spend the tokens that have to be deposited."),(0,o.kt)("li",{parentName:"ol"},"Make ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"depositFor"))," call on ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"RootChainManager")),".")),(0,o.kt)("p",null,"Withdrawing ERC1155 -"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"Burn"))," tokens on Polygon chain."),(0,o.kt)("li",{parentName:"ol"},"Call ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"exit"))," function on ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"RootChainManager"))," to submit proof of burn transaction. This call can be made ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"after checkpoint"))," is submitted for the block containing burn transaction.")),(0,o.kt)("h2",{id:"step-details"},"Step Details"),(0,o.kt)("h3",{id:"instantiate-the-contracts"},"Instantiate the contracts"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const mainWeb3 = new Web3(mainProvider)\nconst maticWeb3 = new Web3(maticProvider)\nconst rootTokenContract = new mainWeb3.eth.Contract(rootTokenABI, rootTokenAddress)\nconst rootChainManagerContract = new mainWeb3.eth.Contract(rootChainManagerABI, rootChainManagerAddress)\nconst childTokenContract = new maticWeb3(childTokenABI, childTokenAddress)\n")),(0,o.kt)("h3",{id:"approve"},"Approve"),(0,o.kt)("p",null,"Provide approval for the ",(0,o.kt)("strong",{parentName:"p"},"ERC1155Predicate")," to spend tokens by calling the ",(0,o.kt)("strong",{parentName:"p"},"setApprovalForAll")," method of token contract. This function takes two arguments ",(0,o.kt)("strong",{parentName:"p"},"operator")," and ",(0,o.kt)("strong",{parentName:"p"},"approved"),". ",(0,o.kt)("strong",{parentName:"p"},"Operator")," is the address that is being approved to spend user's tokens. ",(0,o.kt)("strong",{parentName:"p"},"Approved")," is a boolean indicating if tokens can be spent."),(0,o.kt)("p",null,"This is what the ",(0,o.kt)("strong",{parentName:"p"},"setApprovalForAll")," method looks like "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"await rootTokenContract.methods\n  .setApprovalForAll(erc1155Predicate, true)\n  .send({ from: userAddress })\n")),(0,o.kt)("h3",{id:"deposit"},"Deposit"),(0,o.kt)("p",null,"Note that the token needs to be mapped and approved for deposit before making this call.",(0,o.kt)("br",{parentName:"p"}),"\n","Call the ",(0,o.kt)("inlineCode",{parentName:"p"},"depositFor")," function of ",(0,o.kt)("inlineCode",{parentName:"p"},"RootChainManager")," contract. This function takes 3 arguments: ",(0,o.kt)("inlineCode",{parentName:"p"},"userAddress"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"rootToken"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"depositData"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"userAddress")," is the address of the user that will receive the deposit on the Polygon chain. ",(0,o.kt)("inlineCode",{parentName:"p"},"rootToken")," is the address of the token on the main chain. ",(0,o.kt)("inlineCode",{parentName:"p"},"depositData")," is the ABI-encoded list of ids, list of tokens and bytes data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const depositData = mainWeb3.eth.abi.encodeParameters(\n  ['uint256[]', 'uint256[]', 'bytes'],\n  idList, amountList, data\n)\nawait rootChainManagerContract.methods\n  .depositFor(userAddress, rootToken, depositData)\n  .send({ from: userAddress })\n")),(0,o.kt)("h3",{id:"burn"},"Burn"),(0,o.kt)("p",null,"Tokens can be burned on Polygon chain by calling the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"withdrawSingle"))," or ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"withdrawBatch"))," function on child token contract. withdrawSingle takes two arguments, ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"id"))," and ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"amount"))," indicating the tokens to be burned. withdrawBatch takes 2 arguments, list of ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"ids"))," and list of ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"amounts")),". Proof of this burn needs to be submitted in the exit step. So store the transaction hash."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// For single burn\nconst burnTx = await childTokenContract.methods\n  .withdrawSingle(id, amount)\n  .send({ from: userAddress })\nconst burnTxHash = burnTx.transactionHash\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// For batch burn\nconst burnTx = await childTokenContract.methods\n  .withdrawBatch(idList, amountList)\n  .send({ from: userAddress })\nconst burnTxHash = burnTx.transactionHash\n")),(0,o.kt)("h3",{id:"exit"},"Exit"),(0,o.kt)("p",null,"The exit function on ",(0,o.kt)("inlineCode",{parentName:"p"},"RootChainManager")," contract has to be called to unlock and receive the tokens back from ",(0,o.kt)("inlineCode",{parentName:"p"},"ERC1155Predicate"),". This function takes a single bytes argument that proves the burn transaction. Wait for the checkpoint containing the burn transaction to be submitted before calling this function. The Proof is generated by RLP encoding the following fields -"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"headerNumber - Checkpoint header block number containing the burn tx"),(0,o.kt)("li",{parentName:"ol"},"blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root"),(0,o.kt)("li",{parentName:"ol"},"blockNumber - Block number containing the burn tx on child chain"),(0,o.kt)("li",{parentName:"ol"},"blockTime - Burn tx block time"),(0,o.kt)("li",{parentName:"ol"},"txRoot - Transactions root of block"),(0,o.kt)("li",{parentName:"ol"},"receiptRoot - Receipts root of block"),(0,o.kt)("li",{parentName:"ol"},"receipt - Receipt of the burn transaction"),(0,o.kt)("li",{parentName:"ol"},"receiptProof - Merkle proof of the burn receipt"),(0,o.kt)("li",{parentName:"ol"},"branchMask - 32 bits denoting the path of receipt in merkle patricia tree"),(0,o.kt)("li",{parentName:"ol"},"receiptLogIndex - Log Index to read from the receipt")),(0,o.kt)("p",null,"Generating proof manually can be tricky so it is advisable to use Polygon Edge. If you want to send the transaction manually, you can pass ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"encodeAbi"))," as ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"true"))," in the options object to get raw calldata."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const exitCalldata = await maticPOSClient\n  .exitSingleERC1155(burnTxHash, { from, encodeAbi: true })\n")),(0,o.kt)("p",null,"Send this calldata to ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"RootChainManager")),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"await mainWeb3.eth.sendTransaction({\n  from: userAddress,\n  to: rootChainManagerAddress,\n  data: exitCalldata.data\n})\n")))}u.isMDXComponent=!0}}]);