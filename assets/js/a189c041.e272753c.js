"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[97870],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),m=l(n),u=r,f=m["".concat(s,".").concat(u)]||m[u]||d[u]||i;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},69671:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return c},metadata:function(){return l},toc:function(){return d}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),o=["components"],c={id:"predicates",title:"Predicates in Polygon Plasma",description:"Implementation details of Predicates in Polygon Plasma",keywords:["docs","matic","polygon","plasma","predicates"],image:"https://matic.network/banners/matic-network-16x9.png"},s="Predicates in Polygon Plasma",l={unversionedId:"pos/contracts/plasma_contracts/predicates",id:"pos/contracts/plasma_contracts/predicates",title:"Predicates in Polygon Plasma",description:"Implementation details of Predicates in Polygon Plasma",source:"@site/docs/pos/contracts/plasma_contracts/predicates.md",sourceDirName:"pos/contracts/plasma_contracts",slug:"/pos/contracts/plasma_contracts/predicates",permalink:"/matic-docs/docs/pos/contracts/plasma_contracts/predicates",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/pos/contracts/plasma_contracts/predicates.md",tags:[],version:"current",lastUpdatedBy:"Kennedy Batista",lastUpdatedAt:1686621530,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"predicates",title:"Predicates in Polygon Plasma",description:"Implementation details of Predicates in Polygon Plasma",keywords:["docs","matic","polygon","plasma","predicates"],image:"https://matic.network/banners/matic-network-16x9.png"},sidebar:"pos",previous:{title:"Account Based Plasma",permalink:"/matic-docs/docs/pos/contracts/plasma_contracts/account_based_plasma"},next:{title:"Important contracts",permalink:"/matic-docs/docs/pos/contracts/plasma_contracts/important-contracts"}},p={},d=[{value:"Predicate for ERC20/721 token transfer",id:"predicate-for-erc20721-token-transfer",level:2}],m={toc:d};function u(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"predicates-in-polygon-plasma"},"Predicates in Polygon Plasma"),(0,i.kt)("p",null,"This article highlights the implementation details of our predicate design. Our predicate design is heavily inspired from\xa0",(0,i.kt)("a",{parentName:"p",href:"https://medium.com/plasma-group/plapps-and-predicates-understanding-the-generalized-plasma-architecture-fc171b25741"},"Understanding the Generalized Plasma Architecture"),"\xa0and we thank the plasma group for the same. We recently published our\xa0",(0,i.kt)("a",{parentName:"p",href:"https://ethresear.ch/t/account-based-plasma-morevp/5480"},"Account based MoreVP"),"\xa0specification. The linked post is a pre-requisite to understanding this document."),(0,i.kt)("p",null,"Note:\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"withdrawManager"),"\xa0is our term for what plasma group calls the\xa0",(0,i.kt)("em",{parentName:"p"},"commitment contract"),"."),(0,i.kt)("h2",{id:"predicate-for-erc20721-token-transfer"},"Predicate for ERC20/721 token transfer"),(0,i.kt)("p",null,"The most relevant functions in the ERC20/721 predicates are\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"startExit"),"\xa0and\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"verifyDeprecation"),". See\xa0",(0,i.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/contracts/blob/master/contracts/root/predicates/IPredicate.sol"},"IPredicate.sol\xa05"),"."),(0,i.kt)("p",null,"The\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"startExit"),"\xa0function will be invoked when an exitor wants to start a MoreVP style exit (referencing the preceding reference transactions)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'function startExit(bytes calldata data, bytes calldata exitTx) external {\n  referenceTxData = decode(data)\n\n  // Verify inclusion of reference tx in checkpoint / commitment// returns priority which is something like that defined in minimum viable plasma (blknum * 1000000000 + txindex * 10000 + logIndex)// Here, logIndex is the index of the log in the tx receipt.\n  priority = withdrawManager.verifyInclusion(referenceTxData)\n\n  // validate exitTx - This may be an in-flight tx, so inclusion will not be checked\n  exitAmount = processExitTx(exitTx)\n\n  // returns the balance of the party at the end of referenceTx - this is the "youngest input" to the exitTx\n  closingBalance = processReferenceTx(referenceTxData)\n\n  // The closing balance of the exitTx should be <= the referenced balancerequire(\n    closingBalance >= exitAmount,\n    "Exiting with more tokens than referenced"\n  );\n\n  withdrawManager.addExitToQueue(msg.sender, token, exitAmount, priority)\n}\n')),(0,i.kt)("p",null,"For challenging older state transitions, the predicate exposes\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"verifyDeprecation"),"\xa0function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"function verifyDeprecation(bytes calldata exit, bytes calldata challengeData) external returns (bool) {\n  referenceTxData = decode(challengeData)\n\n  Verify the signature on the referenceTxData.rawTx and the fact that rawTx calls some function in the associated contract on plasma chain that deprecates the state\n\n  // Verify inclusion of challenge tx in checkpoint / commitment\n  priorityOfChallengeTx = withdrawManager.verifyInclusion(referenceTxData)\n\n  return priorityOfChallengeTx > exit.priority\n}\n")),(0,i.kt)("p",null,"Finally, the\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"challengeExit"),"\xa0function in\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"withdrawManager"),"\xa0is responsible for calling\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"predicate.verifyDeprecation"),"\xa0and cancel the exit if it returns true. See\xa0",(0,i.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/contracts/blob/master/contracts/root/withdrawManager/WithdrawManager.sol#L184"},"WithdrawManager.sol"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'function challengeExit(uint256 exitId, uint256 inputId, bytes calldata challengeData) external {\n  PlasmaExit storage exit = exits[exitId];\n  Input storage input = exit.inputs[inputId];\n  require(\n    exit.token != address(0x0) && input.signer != address(0x0),\n    "Invalid exit or input id"\n  );\n  bool isChallengeValid = IPredicate(exit.predicate).verifyDeprecation(\n    encodeExit(exit),\n    encodeInputUtxo(inputId, input),\n    challengeData\n  );\n  if (isChallengeValid) {\n    deleteExit(exitId);\n    emit ExitCancelled(exitId);\n  }\n}\n')),(0,i.kt)("p",null,"While this makes up the crux of our\xa0",(0,i.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/contracts/blob/master/contracts/root/predicates/ERC20Predicate.sol"},"ERC20Predicate.sol"),"\xa0logic, the actual implementation is much more involved and can be found in this\xa0",(0,i.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/contracts/pull/78"},"pull request\xa012"),". We invite the plasma community to review the same and leave their precious feedback here or on the PR."))}u.isMDXComponent=!0}}]);