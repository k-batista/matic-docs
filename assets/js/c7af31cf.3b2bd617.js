"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[2921],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return m}});var r=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,o=function(e,t){if(null==e)return{};var a,r,o={},n=Object.keys(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,o=e.mdxType,n=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(a),m=o,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||n;return a?r.createElement(h,i(i({ref:t},u),{},{components:a})):r.createElement(h,i({ref:t},u))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var n=a.length,i=new Array(n);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<n;c++)i[c]=a[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},17030:function(e,t,a){a.r(t),a.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var r=a(87462),o=a(63366),n=(a(67294),a(3905)),i=["components"],s={id:"security-models",title:"Security Models",description:"PoS, Plasma and Hybrid securities",keywords:["docs","matic","polygon","security","implementation"],image:"https://wiki.polygon.technology/img/polygon-logo.png"},l="Security Models",c={unversionedId:"home/architecture/security-models",id:"home/architecture/security-models",title:"Security Models",description:"PoS, Plasma and Hybrid securities",source:"@site/docs/home/architecture/security-models.md",sourceDirName:"home/architecture",slug:"/home/architecture/security-models",permalink:"/matic-docs/docs/home/architecture/security-models",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/home/architecture/security-models.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686625626,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"security-models",title:"Security Models",description:"PoS, Plasma and Hybrid securities",keywords:["docs","matic","polygon","security","implementation"],image:"https://wiki.polygon.technology/img/polygon-logo.png"},sidebar:"pos",previous:{title:"How does State Sync work?",permalink:"/matic-docs/docs/pos/state-sync/how-state-sync-works"}},u={},p=[{value:"Proof of Stake Security",id:"proof-of-stake-security",level:2},{value:"Plasma Security",id:"plasma-security",level:2},{value:"Hybrid",id:"hybrid",level:2}],d={toc:p};function m(e){var t=e.components,a=(0,o.Z)(e,i);return(0,n.kt)("wrapper",(0,r.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"security-models"},"Security Models"),(0,n.kt)("p",null,"Polygon provides three types of security models for a developer to build their dApps upon:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("a",{parentName:"li",href:"#proof-of-stake-security"},"Proof of Stake security")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("a",{parentName:"li",href:"#plasma-security"},"Plasma security")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("a",{parentName:"li",href:"#hybrid"},"Hybrid (Plasma + PoS)"))),(0,n.kt)("p",null,"We have described each of these security models offered by Polygon and the developer workflow for each with an example dApp below."),(0,n.kt)("h2",{id:"proof-of-stake-security"},"Proof of Stake Security"),(0,n.kt)("p",null,"Proof of Stake (PoS) security is provided by the Heimdall & Bor layer which is built on top of Tendermint. A checkpoint is committed to the root chain only when \u2154 of the validators have signed on it."),(0,n.kt)("p",null,"To enable the PoS mechanism on our platform, we employ a set of staking management contracts on Ethereum, as well as a set of incentivized validators running Heimdall and Bor nodes. This implements the following features:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The ability for anyone to stake MATIC tokens on the Ethereum smart contract and join the system as a Validator"),(0,n.kt)("li",{parentName:"ul"},"Earn staking rewards for validating state transitions on Polygon")),(0,n.kt)("p",null,"The PoS mechanism also acts as a mitigation to the data unavailability problem for our sidechains in terms of Plasma."),(0,n.kt)("p",null,"We have a fast finality layer that finalizes the sidechain state periodically via checkpoints. The fast finality helps us cement sidechain state. The EVM compatible chain has few validators and faster block time with high throughput. It chooses scalability over high degrees of decentralization. Heimdall ensures that the final state commit is bulletproof and passes via a large validator set and hence high decentralization."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For developers")),(0,n.kt)("p",null,"As a dApp developer building on PoS security, the procedure is as simple as taking your smart contract and deploying it on the Polygon PoS network. This is possible because of the account based architecture enabling an EVM-compatible sidechain."),(0,n.kt)("h2",{id:"plasma-security"},"Plasma Security"),(0,n.kt)("p",null,'Polygon provides "Plasma Guarantees" with respect to various attack scenarios. Two main cases considered are:'),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Chain operator (or in Polygon, the Heimdall layer) is corrupt, or"),(0,n.kt)("li",{parentName:"ul"},"The user is corrupt")),(0,n.kt)("p",null,"In either case, if a user\u2019s assets on the plasma chain have been compromised, they need to start mass exiting. Polygon provides constructions on the rootchain smart contract that can be leveraged. For more details and technical specifications regarding this construction and attack vectors considered, read ",(0,n.kt)("a",{parentName:"p",href:"https://ethresear.ch/t/account-based-plasma-morevp/5480"},"here"),"."),(0,n.kt)("p",null,"Effectively, security offered by Polygon's Plasma contracts piggybacks on Ethereum\u2019s security. Users\u2019 funds are only ever at risk if Ethereum fails. Put simply, a plasma chain is as secure as the main chain consensus mechanism. This can be extrapolated to say that the plasma chain can use really simple consensus mechanisms and still be safe."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"For developers")),(0,n.kt)("p",null,"As a dApp developer, if you would like to build on Polygon with Plasma security guarantee, you are required to write custom predicates for your smart contracts. This basically means writing the external contracts that handle the dispute conditions set in place by the Polygon plasma constructs."),(0,n.kt)("h2",{id:"hybrid"},"Hybrid"),(0,n.kt)("p",null,"Apart from pure Plasma security and pure Proof of Stake security which is possible in dApps deployed on Polygon, there is also a Hybrid approach that developers can follow - which simply means having both Plasma and Proof of Stake guarantees on some particular workflows of the dApp."),(0,n.kt)("p",null,"This approach is better understood with an example."),(0,n.kt)("p",null,"Consider a gaming dApp with a set of smart contracts that describe the game\u2019s logic. Let\u2019s say the game uses its own ERC20 token to reward players. Now, the smart contracts defining the game logic can be deployed on Polygon sidechain directly - guaranteeing Proof of Stake security to the contracts while the ERC20 token transfer can be secured with Plasma guarantees and fraud proof embedded in Polygon's root chain contracts."))}m.isMDXComponent=!0}}]);