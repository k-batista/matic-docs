"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[60581],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return m}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(a),m=r,k=p["".concat(s,".").concat(m)]||p[m]||u[m]||o;return a?n.createElement(k,i(i({ref:t},c),{},{components:a})):n.createElement(k,i({ref:t},c))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var d=2;d<o;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},8877:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return u}});var n=a(87462),r=a(63366),o=(a(67294),a(3905)),i=["components"],l={id:"delegation",title:"Delegation via Validator Shares",sidebar_label:"Delegation",description:"Delegation via Validator Shares",keywords:["polygon wiki","docs","polygon","delegation","validator shares"],image:"https://wiki.polygon.technology/img/polygon-logo.png"},s=void 0,d={unversionedId:"pos/contracts/delegation",id:"pos/contracts/delegation",title:"Delegation via Validator Shares",description:"Delegation via Validator Shares",source:"@site/docs/pos/contracts/delegation.md",sourceDirName:"pos/contracts",slug:"/pos/contracts/delegation",permalink:"/matic-docs/docs/pos/contracts/delegation",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/pos/contracts/delegation.md",tags:[],version:"current",lastUpdatedBy:"Kennedy Batista",lastUpdatedAt:1686621530,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"delegation",title:"Delegation via Validator Shares",sidebar_label:"Delegation",description:"Delegation via Validator Shares",keywords:["polygon wiki","docs","polygon","delegation","validator shares"],image:"https://wiki.polygon.technology/img/polygon-logo.png"},sidebar:"pos",previous:{title:"Staking Manager",permalink:"/matic-docs/docs/pos/contracts/stakingmanager"},next:{title:"Plasma Contracts",permalink:"/matic-docs/docs/category/plasma-contracts-1"}},c={},u=[{value:"Technical Specification",id:"technical-specification",level:2},{value:"Methods and Variables",id:"methods-and-variables",level:2},{value:"buyVoucher",id:"buyvoucher",level:3},{value:"sellVoucher",id:"sellvoucher",level:3},{value:"withdrawRewards",id:"withdrawrewards",level:3},{value:"reStake",id:"restake",level:3},{value:"unStakeClaimTokens",id:"unstakeclaimtokens",level:3},{value:"updateCommissionRate",id:"updatecommissionrate",level:3},{value:"updateRewards",id:"updaterewards",level:3}],p={toc:u};function m(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Polygon supports delegation via validator shares. By using this design, it is easier to distribute rewards and slash with scale (thousands of delegators) on Ethereum contracts without much computation."),(0,o.kt)("p",null,"Delegators delegate by purchasing shares of a finite pool from validators. Each validator will have their own validator share token. Let's call these fungible tokens ",(0,o.kt)("inlineCode",{parentName:"p"},"VATIC")," for a validator ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),". As soon as a user delegates to a validator ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),", they will be issued ",(0,o.kt)("inlineCode",{parentName:"p"},"VATIC")," based on an exchange rate of ",(0,o.kt)("inlineCode",{parentName:"p"},"MATIC/VATIC")," pair. As users accrue value the exchange rate indicates that they can now withdraw more ",(0,o.kt)("inlineCode",{parentName:"p"},"MATIC")," for each ",(0,o.kt)("inlineCode",{parentName:"p"},"VATIC")," and when users get slashed, users withdraw less ",(0,o.kt)("inlineCode",{parentName:"p"},"MATIC")," for their ",(0,o.kt)("inlineCode",{parentName:"p"},"VATIC"),"."),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"MATIC")," is a staking token. A delegator needs to have ",(0,o.kt)("inlineCode",{parentName:"p"},"MATIC")," tokens to participate in the delegation."),(0,o.kt)("p",null,"Initially, a delegator ",(0,o.kt)("inlineCode",{parentName:"p"},"D")," buys tokens from validator ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," specific pool when ",(0,o.kt)("inlineCode",{parentName:"p"},"1 MATIC per 1 VATIC"),"."),(0,o.kt)("p",null,"When a validator gets rewarded with more ",(0,o.kt)("inlineCode",{parentName:"p"},"MATIC")," tokens, new tokens are added to the pool. Let's say with the current pool of ",(0,o.kt)("inlineCode",{parentName:"p"},"100 MATIC")," tokens, ",(0,o.kt)("inlineCode",{parentName:"p"},"10 MATIC")," rewards are added to the pool. But since the total supply of ",(0,o.kt)("inlineCode",{parentName:"p"},"VATIC")," tokens didn't change due to rewards, the exchange rate becomes ",(0,o.kt)("inlineCode",{parentName:"p"},"1 MATIC per 0.9 VATIC"),". Now, delegator ",(0,o.kt)("inlineCode",{parentName:"p"},"D")," gets more ",(0,o.kt)("inlineCode",{parentName:"p"},"MATIC")," for the same shares."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"VATIC"),": Validator specific minted validator share tokens (ERC20 tokens)"),(0,o.kt)("h2",{id:"technical-specification"},"Technical Specification"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 public validatorId; // Delegation contract for validator\nuint256 public validatorRewards; // accumulated rewards for validator\nuint256 public commissionRate; // validator's cut %\nuint256 public validatorDelegatorRatio = 10; // to be implemented/used\n\nuint256 public totalStake;\nuint256 public rewards; // rewards for pool of delegation stake\nuint256 public activeAmount; // # of tokens delegated which are part of active stake\n")),(0,o.kt)("p",null,"Exchange rate is calculated as below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"ExchangeRate = (totalDelegatedPower + delegatorRewardPool) / totalDelegatorShares\n")),(0,o.kt)("h2",{id:"methods-and-variables"},"Methods and Variables"),(0,o.kt)("h3",{id:"buyvoucher"},"buyVoucher"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function buyVoucher(uint256 _amount) public;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Transfer the ",(0,o.kt)("inlineCode",{parentName:"li"},"_amount")," to stakeManager and update the timeline data structure for active stake."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateValidatorState")," is used to update timeline DS."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Mint")," delegation shares using current ",(0,o.kt)("inlineCode",{parentName:"li"},"exchangeRate")," for ",(0,o.kt)("inlineCode",{parentName:"li"},"_amount"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"amountStaked")," is used to keep track of active stake of each delegator in order to calculate liquid rewards.")),(0,o.kt)("h3",{id:"sellvoucher"},"sellVoucher"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function sellVoucher() public;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Using current ",(0,o.kt)("inlineCode",{parentName:"li"},"exchangeRate")," and number of shares to calculate total amount (active stake + rewards)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"unBond")," active stake from validator and transfer rewards to delegator, if any."),(0,o.kt)("li",{parentName:"ul"},"Must remove active stake from timeline using ",(0,o.kt)("inlineCode",{parentName:"li"},"updateValidatorState")," in stakeManger."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"delegators")," mapping is used to keep track of stake in withdrawal period.")),(0,o.kt)("h3",{id:"withdrawrewards"},"withdrawRewards"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function withdrawRewards() public;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For a delegator, calculate the rewards and transfer, and depending upon ",(0,o.kt)("inlineCode",{parentName:"li"},"exchangeRate")," burn count of shares."),(0,o.kt)("li",{parentName:"ul"},"Example: if a delegator owns 100 shares and exchange rate is 200 so rewards are 100 tokens, transfer 100 tokens to delegator. Remaining stake is 100 so using exchange rate 200, now it is worth 50 shares. So burn 50 shares. Delegator now has 50 shares worth 100 tokens (which he initially staked / delegated).")),(0,o.kt)("h3",{id:"restake"},"reStake"),(0,o.kt)("p",null,"Restake can work in two ways: delegator can buy more shares using ",(0,o.kt)("inlineCode",{parentName:"p"},"buyVoucher")," or reStake rewards."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function reStake() public;\n")),(0,o.kt)("p",null,"Above function is used to reStake rewards. The number of shares aren\u2019t affected because ",(0,o.kt)("inlineCode",{parentName:"p"},"exchangeRate")," is the same; so just the rewards are moved into active stake for both validator share contract and stakeManager timeline."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"getLiquidRewards")," is used for calculating accumulated rewards i.e., delegator owns 100 share and exchange rate is 200, so rewards are 100 tokens. Move 100 tokens into active stake, since exchange rate is still same number of share will also remain same. Only difference is that now 200 tokens are considered into active stake and can't be withdrawn immediately (not a part of liquid rewards)."),(0,o.kt)("p",null,"Purpose of reStaking is that since delegator's validator has now more active stake and they will earn more rewards for that so will the delegator."),(0,o.kt)("h3",{id:"unstakeclaimtokens"},"unStakeClaimTokens"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function unStakeClaimTokens()\n")),(0,o.kt)("p",null,"Once withdrawal period is over, delegators who've sold their shares can claim their MATIC tokens. Must transfer tokens to user."),(0,o.kt)("h3",{id:"updatecommissionrate"},"updateCommissionRate"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function updateCommissionRate(uint256 newCommissionRate)\n        external\n        onlyValidator\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Updates commission % for the validator.")),(0,o.kt)("h3",{id:"updaterewards"},"updateRewards"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function updateRewards(uint256 reward, uint256 checkpointStakePower, uint256 validatorStake)\n        external\n        onlyOwner\n        returns (uint256)\n")),(0,o.kt)("p",null,"When a validator gets rewards for submitting checkpoint, this function is called for disbursements of rewards between validator and delegators."))}m.isMDXComponent=!0}}]);