"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[42730],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return f}});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),d=l(n),f=r,h=d["".concat(c,".").concat(f)]||d[f]||p[f]||s;return n?o.createElement(h,i(i({ref:t},u),{},{components:n})):o.createElement(h,i({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=d;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:r,i[1]=a;for(var l=2;l<s;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},46449:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return a},metadata:function(){return l},toc:function(){return p}});var o=n(87462),r=n(63366),s=(n(67294),n(3905)),i=["components"],a={id:"polybft-overview",title:"Polygon Byzantine Fault Tolerance (PolyBFT)",sidebar_label:"Polygon Byzantine Fault Tolerance (PolyBFT)",description:"Learn about the new consensus mechanism for the Edge client.",keywords:["docs","polygon","edge","consensus","polybft","pos"]},c=void 0,l={unversionedId:"supernets/design/consensus/polybft/polybft-overview",id:"supernets/design/consensus/polybft/polybft-overview",title:"Polygon Byzantine Fault Tolerance (PolyBFT)",description:"Learn about the new consensus mechanism for the Edge client.",source:"@site/docs/supernets/design/consensus/polybft/overview.md",sourceDirName:"supernets/design/consensus/polybft",slug:"/supernets/design/consensus/polybft/polybft-overview",permalink:"/matic-docs/docs/supernets/design/consensus/polybft/polybft-overview",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/supernets/design/consensus/polybft/overview.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686626387,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"polybft-overview",title:"Polygon Byzantine Fault Tolerance (PolyBFT)",sidebar_label:"Polygon Byzantine Fault Tolerance (PolyBFT)",description:"Learn about the new consensus mechanism for the Edge client.",keywords:["docs","polygon","edge","consensus","polybft","pos"]},sidebar:"supernets",previous:{title:"PolyBFT Consensus",permalink:"/matic-docs/docs/category/polybft-consensus"},next:{title:"Istanbul Byzantine Fault Tolerant (IBFT) 2.0",permalink:"/matic-docs/docs/supernets/design/consensus/polybft/ibft-overview"}},u={},p=[{value:"Overview",id:"overview",level:2},{value:"Bridge",id:"bridge",level:2}],d={toc:p};function f(e){var t=e.components,a=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,o.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This document provides an overview of Polygon Byzantine Fault Tolerance (PolyBFT), the consensus mechanism of Polygon Supernets."),(0,s.kt)("h2",{id:"overview"},"Overview"),(0,s.kt)("p",null,"PolyBFT is a sophisticated and robust consensus mechanism employed by Polygon Supernets.\nThe consensus mechanism comprises two key components, a ",(0,s.kt)("strong",{parentName:"p"},"consensus engine")," and ",(0,s.kt)("strong",{parentName:"p"},"consensus protocol"),".\nPolyBFT utilizes the IBFT consensus engine and a Proof-of-Stake architecture to seal blocks, provide specific network capabilities, and govern the network.\nThe core smart contracts work in tandem with the consensus engine to define all the network's Proof-of-Stake rules."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"bridge",src:n(51632).Z,width:"1016",height:"340"})),(0,s.kt)("p",null,"The consensus engine of PolyBFT is based on the Istanbul Byzantine Fault Tolerance ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/0xPolygon/go-ibft"},"(IBFT 2.0) protocol"),", which is responsible for sealing blocks on the blockchain.\nThe IBFT 2.0 protocol ensures that network integrity is maintained even in the presence of malicious or dishonest nodes."),(0,s.kt)("p",null,"To achieve fault tolerance, IBFT allows for ",(0,s.kt)("inlineCode",{parentName:"p"},"f")," faulty nodes in a ",(0,s.kt)("inlineCode",{parentName:"p"},"3f + 1"),' network, as long as two-thirds of the nodes are honest. This algorithm is also known as a "super-majority rules" algorithm.\nEach PolyBFT node maintains a local copy of the blockchain, represented as a list of blocks similar to the blockchain. The height of a block is defined as the number of parent links that separate the block from the genesis block, with the genesis block having a height of 0. Sequential instances of a block finalization protocol are run, with the objective of each instance being to determine which block is to be added at height h of the blockchain.'),(0,s.kt)("p",null,"PolyBFT's consensus protocol is implemented through a set of core smart contracts. These contracts serve multiple purposes, including enabling staking functionality and defining an incentivization scheme for validators on the network, managing the validator set, and facilitating cross-chain communication through a native bridge."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"bridge",src:n(72562).Z,width:"1811",height:"725"})),(0,s.kt)("h2",{id:"bridge"},"Bridge"),(0,s.kt)("p",null,"The bridge transfers assets and data between a Supernet and an external EVM-compatible blockchain (rootchain), making it a critical component of the network's interoperability. Two predicate contracts, one on the and one on the rootchain, implement the core bridge functionality and use the associated core contracts to deposit, withdraw, and verify cross-chain bridge transactions. The diagram below illustrates how the core contracts fit into the overall smart contract system design."))}f.isMDXComponent=!0},72562:function(e,t,n){t.Z=n.p+"assets/images/contracts.excalidraw-74ed73e5aac6a9e950d76ecc651b0272.png"},51632:function(e,t,n){t.Z=n.p+"assets/images/polybft.excalidraw-79fe91d34e2d928744498e8ff4cda3ea.png"}}]);