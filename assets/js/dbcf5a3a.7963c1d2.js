"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[29928],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return u}});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=o.createContext({}),l=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},h=function(e){var t=l(e.components);return o.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=l(n),u=a,m=d["".concat(i,".").concat(u)]||d[u]||p[u]||r;return n?o.createElement(m,c(c({ref:t},h),{},{components:n})):o.createElement(m,c({ref:t},h))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,c=new Array(r);c[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,c[1]=s;for(var l=2;l<r;l++)c[l]=n[l];return o.createElement.apply(null,c)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},74053:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return i},metadata:function(){return h},toc:function(){return d}});var o=n(87462),a=n(63366),r=(n(67294),n(3905)),c=n(44996),s=["components"],i={id:"checkpoint",title:"Checkpoint",description:"Snapshots of the Bor chain state submitted to Ethereum",keywords:["docs","matic","polygon","checkpoint","snapshots of bor chain","ethereum"],image:"https://matic.network/banners/matic-network-16x9.png"},l="Checkpoint",h={unversionedId:"pos/heimdall/checkpoint",id:"pos/heimdall/checkpoint",title:"Checkpoint",description:"Snapshots of the Bor chain state submitted to Ethereum",source:"@site/docs/pos/heimdall/checkpoint.md",sourceDirName:"pos/heimdall",slug:"/pos/heimdall/checkpoint",permalink:"/matic-docs/docs/pos/heimdall/checkpoint",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/pos/heimdall/checkpoint.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686626387,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"checkpoint",title:"Checkpoint",description:"Snapshots of the Bor chain state submitted to Ethereum",keywords:["docs","matic","polygon","checkpoint","snapshots of bor chain","ethereum"],image:"https://matic.network/banners/matic-network-16x9.png"},sidebar:"pos",previous:{title:"Heimdall Validators",permalink:"/matic-docs/docs/pos/heimdall/validators"},next:{title:"Validator Key Management",permalink:"/matic-docs/docs/pos/heimdall/validator-key-management"}},p={},d=[{value:"Types",id:"types",level:2},{value:"Root hash",id:"root-hash",level:3},{value:"AccountRootHash",id:"accountroothash",level:3}],u={toc:d};function m(e){var t=e.components,n=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"checkpoint"},"Checkpoint"),(0,r.kt)("p",null,"Checkpoints are the most crucial part of the Polygon network. It represents snapshots of the Bor chain state and is supposed to be attested by \u2154+ of the validator set before it is validated and submitted on the contracts deployed on Ethereum."),(0,r.kt)("h2",{id:"types"},"Types"),(0,r.kt)("p",null,"Checkpoint structure on Heimdall state looks like following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type CheckpointBlockHeader struct {\n    // Proposer is selected based on stake\n    Proposer        types.HeimdallAddress `json:"proposer"`\n\n    // StartBlock: The block number on Bor from which this checkpoint starts\n    StartBlock      uint64                `json:"startBlock"`\n\n    // EndBlock: The block number on Bor from which this checkpoint ends\n    EndBlock        uint64                `json:"endBlock"`\n\n    // RootHash is the Merkle root of all the leaves containing the block\n    // headers starting from start to the end block\n    RootHash        types.HeimdallHash    `json:"rootHash"`\n\n    // Account root hash for each validator\n  // Hash of data that needs to be passed from Heimdall to Ethereum chain like withdraw topup etc.\n    AccountRootHash types.HeimdallHash    `json:"accountRootHash"`\n\n  // Timestamp when checkpoint was created on Heimdall\n    TimeStamp       uint64          `json:"timestamp"`\n}\n')),(0,r.kt)("h3",{id:"root-hash"},"Root hash"),(0,r.kt)("img",{src:(0,c.Z)("img/checkpoint/checkpoint.svg")}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RootHash")," is the Merkle hash of Bor block hashes from ",(0,r.kt)("inlineCode",{parentName:"p"},"StartBlock")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"EndBlock"),". Root hash for the checkpoint is created using the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-matlab"},"blockHash = keccak256([number, time, tx hash, receipt hash])\n")),(0,r.kt)("p",null,"Pseudocode for the root hash for ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," Bor blocks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"B(1) := keccak256([number, time, tx hash, receipt hash])\nB(2) := keccak256([number, time, tx hash, receipt hash])\n.\n.\n.\nB(n) := keccak256([number, time, tx hash, receipt hash])\n\n// checkpoint is Merkle root of all block hash\ncheckpoint's root hash = Merkel[B(1), B(2), ....., B(n)]\n")),(0,r.kt)("p",null,"Here are some snippets of how checkpoint is created from Bor chain block headers."),(0,r.kt)("p",null,"Source: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/heimdall/blob/develop/checkpoint/types/merkel.go#L60-L114"},"https://github.com/maticnetwork/heimdall/blob/develop/checkpoint/types/merkel.go#L60-L114")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// Golang representation of block data used in checkpoint\nblockData := crypto.Keccak256(appendBytes32(\n    blockHeader.Number.Bytes(),\n    new(big.Int).SetUint64(blockHeader.Time).Bytes(),\n    blockHeader.TxHash.Bytes(),\n    blockHeader.ReceiptHash.Bytes(),\n))\n\n// array of block hashes of Bor blocks\nheaders := [blockData1, blockData2, ..., blockDataN]\n\n// merkel tre\ntree := merkle.NewTreeWithOpts(merkle.TreeOptions{EnableHashSorting: false, DisableHashLeaves: true})\ntree.Generate(convert(headers), sha3.NewLegacyKeccak256())\n\n// create checkpoint's root hash\nrootHash := tree.Root().Hash\n")),(0,r.kt)("h3",{id:"accountroothash"},"AccountRootHash"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"AccountRootHash")," is the hash of the validator account-related information that needs to pass to the Ethereum chain at each checkpoint."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"eachAccountHash := keccak256([validator id, withdraw fee, slash amount])\n")),(0,r.kt)("p",null,"Pseudocode for the account root hash for ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," Bor blocks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"B(1) := keccak256([validator id, withdraw fee, slash amount])\nB(2) := keccak256([validator id, withdraw fee, slash amount])\n.\n.\n.\nB(n) := keccak256([validator id, withdraw fee, slash amount])\n\n// account root hash is Merkle root of all block hash\ncheckpoint's account root hash = Merkel[B(1), B(2), ....., B(n)]\n")),(0,r.kt)("p",null,"Golang code for the account hash can be found here: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/heimdall/blob/develop/types/dividend-account.go#L91-L101"},"https://github.com/maticnetwork/heimdall/blob/develop/types/dividend-account.go#L91-L101")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// DividendAccount contains Fee, Slashed amount\ntype DividendAccount struct {\n    ID            DividendAccountID `json:"ID"`\n    FeeAmount     string            `json:"feeAmount"`     // string representation of big.Int\n    SlashedAmount string            `json:"slashedAmount"` // string representation of big.Int\n}\n\n// calculate hash for particular account\nfunc (da DividendAccount) CalculateHash() ([]byte, error) {\n    fee, _ := big.NewInt(0).SetString(da.FeeAmount, 10)\n    slashAmount, _ := big.NewInt(0).SetString(da.SlashedAmount, 10)\n    divAccountHash := crypto.Keccak256(appendBytes32(\n        new(big.Int).SetUint64(uint64(da.ID)).Bytes(),\n        fee.Bytes(),\n        slashAmount.Bytes(),\n    ))\n\n    return divAccountHash, nil\n}\n')))}m.isMDXComponent=!0}}]);