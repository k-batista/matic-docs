"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[46334],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(n),d=o,m=p["".concat(c,".").concat(d)]||p[d]||h[d]||r;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},12907:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return h}});var a=n(87462),o=n(63366),r=(n(67294),n(3905)),i=["components"],s={id:"account_based_plasma",title:"Account Based Plasma",description:"An account-based implementation of plasma",keywords:["docs","matic","Account Based Plasma","polygon","implementation"],image:"https://matic.network/banners/matic-network-16x9.png"},c="Account Based Plasma",l={unversionedId:"pos/contracts/plasma_contracts/account_based_plasma",id:"pos/contracts/plasma_contracts/account_based_plasma",title:"Account Based Plasma",description:"An account-based implementation of plasma",source:"@site/docs/pos/contracts/plasma_contracts/account_based_plasma.md",sourceDirName:"pos/contracts/plasma_contracts",slug:"/pos/contracts/plasma_contracts/account_based_plasma",permalink:"/matic-docs/docs/pos/contracts/plasma_contracts/account_based_plasma",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/pos/contracts/plasma_contracts/account_based_plasma.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686625626,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"account_based_plasma",title:"Account Based Plasma",description:"An account-based implementation of plasma",keywords:["docs","matic","Account Based Plasma","polygon","implementation"],image:"https://matic.network/banners/matic-network-16x9.png"},sidebar:"pos",previous:{title:"Plasma Contracts",permalink:"/matic-docs/docs/category/plasma-contracts-1"},next:{title:"Predicates in Polygon Plasma",permalink:"/matic-docs/docs/pos/contracts/plasma_contracts/predicates"}},u={},h=[{value:"PoS layer and Checkpoints",id:"pos-layer-and-checkpoints",level:2},{value:"UTXO-like Event Logs",id:"utxo-like-event-logs",level:2},{value:"Exit Games",id:"exit-games",level:2},{value:"Attack Vectors",id:"attack-vectors",level:2},{value:"Malicious Operator",id:"malicious-operator",level:3},{value:"Malicious User",id:"malicious-user",level:3},{value:"Exit Scenarios",id:"exit-scenarios",level:2},{value:"Burn tokens",id:"burn-tokens",level:3},{value:"Exit from the last ERC20/721 transfers (MoreVP)",id:"exit-from-the-last-erc20721-transfers-morevp",level:3},{value:"Exit from an in-flight transaction (MoreVP)",id:"exit-from-an-in-flight-transaction-morevp",level:3},{value:"Limitations",id:"limitations",level:2}],p={toc:h};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"account-based-plasma"},"Account Based Plasma"),(0,r.kt)("p",null,"Polygon Plasma follows a model similar to ",(0,r.kt)("a",{parentName:"p",href:"https://ethresear.ch/t/more-viable-plasma/2160"},"Plasma MoreVP"),", but is an ",(0,r.kt)("strong",{parentName:"p"},"account-based implementation")," compared to other UTXO-based implementations. The sidechain is EVM-compatible. Using the MoreVP construction, we also eliminate the need for confirmation signatures."),(0,r.kt)("h2",{id:"pos-layer-and-checkpoints"},"PoS layer and Checkpoints"),(0,r.kt)("p",null,"The Polygon Network uses a dual strategy of Proof of Stake at the checkpointing layer and Block Producers at the block producer layer to achieve faster blocktimes and achieves finality on the main chain using the checkpoints and fraud proofs."),(0,r.kt)("p",null,"On Polygon Network\u2019s checkpointing layer, for every few blocks on the block layer of the Polygon Network, a (sufficiently bonded) validator will create a checkpoint on the main chain after validating all the blocks on the block layer and creating the Merkle tree of the block hashes since the last checkpoint."),(0,r.kt)("p",null,"Apart from providing finality on the mainchain, checkpoints play a role in withdrawals as they contain the proof-of-burn (withdrawal) of tokens in the event of user withdrawal. It enables the users to prove their remaining tokens on root contract using Patricia Merkle proof and header block proof. Note that to prove remaining tokens, the header block must be committed to the Root Chain through PoS (Stakeholders). The withdrawal process will incur Ethereum gas fees as usual. We leverage the checkpoints heavily for the exit games."),(0,r.kt)("h2",{id:"utxo-like-event-logs"},"UTXO-like Event Logs"),(0,r.kt)("p",null,"For ERC20/ERC721 transfers, this is achieved by using a UTXO-like event log data structure. Below is a\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"LogTransfer"),"\xa0event for reference."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"event LogTransfer(\n    address indexed token,\n    address indexed from,\n    address indexed to,\n    uint256 amountOrTokenId,\n    uint256 input1, // previous account balance of the sender\n    uint256 input2, // previous account balance of the receiver\n    uint256 output1, // new account balance of the sender\n    uint256 output2 // new account balance of the receiver\n);\n")),(0,r.kt)("p",null,"So, basically every ERC20/ERC721 transfer emits this event and the previous balances of the sender and receiver (",(0,r.kt)("inlineCode",{parentName:"p"},"input1"),"\xa0and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"input2"),") become the input (UTXO like) to the tx and the new balances become the outputs (",(0,r.kt)("inlineCode",{parentName:"p"},"output1"),"\xa0and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"output2"),"). The transfers are tracked by way of collating all the related\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"LogTransfer"),"\xa0events."),(0,r.kt)("h2",{id:"exit-games"},"Exit Games"),(0,r.kt)("p",null,"Since the blocks are produced by a single block producer (or very few), it exposes a surface for fraud. We\u2019ll briefly discuss the attack scenarios and then talk about how the plasma guarantees safeguard a user."),(0,r.kt)("h2",{id:"attack-vectors"},"Attack Vectors"),(0,r.kt)("h3",{id:"malicious-operator"},"Malicious Operator"),(0,r.kt)("p",null,"The following discusses the scenarios where operator could become malicious and try to cheat."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Out-of-nowhere tokens / double spends / malformed receipts that fraudulently increases (for an operator controlled account) / decreases (for a user) the token balance."),(0,r.kt)("li",{parentName:"ol"},"Data unavailabilityAfter a user sends a tx, let\u2019s say the operator included the tx in the plasma block but made the chain data unavailable to the user. In that case, if a user starts an exit from an older tx, then they could be challenged on-chain by showcasing their most recent tx. It becomes easy to grief the user."),(0,r.kt)("li",{parentName:"ol"},"Bad checkpointIn the worst case, an operator could perform A.1 and(or) A.2 and collude with the validators to commit those invalid state transitions to the root chain."),(0,r.kt)("li",{parentName:"ol"},"Halting the side chainThe operator stops producing blocks and the chain comes to a halt. If a checkpoint has not been submitted for a specified duration, it would be possible to mark the side chain as halted on the root chain. After that no more checkpoints can be submitted.")),(0,r.kt)("p",null,"For reasons listed above or otherwise, if the plasma chain has become rogue, the user\u2019s need to start mass exiting and we aspire to provide exit constructions on the root chain that the users can leverage, if and when the time comes."),(0,r.kt)("h3",{id:"malicious-user"},"Malicious User"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"User starts exit from a committed tx but continues to spend tokens on the side chain. Similar to double spending but across 2 chains.")),(0,r.kt)("p",null,"We are building upon the ideas of\xa0",(0,r.kt)("a",{parentName:"p",href:"https://ethresear.ch/t/more-viable-plasma/2160"},"MoreVp\xa07"),".In a nutshell, MoreVP introduces a new way to calculate exit priority, called the \u201cyoungest-input\u201d priority. Instead of ordering exits by the age of the output, moreVP orders exits by the age of the youngest input. This has the effect that exits of outputs, even if they\u2019re included in withheld blocks after \u201cout of nowhere\u201d transactions, will be correctly processed as long as they only stem from valid inputs. We define\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"getAge"),"\xa0which assigns an age to an included tx. This is as defined in\xa0",(0,r.kt)("a",{parentName:"p",href:"https://ethresear.ch/t/minimal-viable-plasma/426"},"minimum viable plasma\xa01"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"function getAge(receipt) {\n  const { headerNumber, plasmaBlockNum, txindex, oindex } = receipt\n  return f(headerNumber, plasmaBlockNum, txindex, oindex) // multiplied with their respective weights\n}\n")),(0,r.kt)("h2",{id:"exit-scenarios"},"Exit Scenarios"),(0,r.kt)("p",null,"Let's introduce some terminology before we continue discussing the exit scenarios:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Withdrawer"),": A user who wants to the exit the plasma chain."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Committed tx"),": A tx that has been included in a Polygon chain block and has been checkpointed on the root chain."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Spend tx"),": A tx that changes the user\u2019s token balance in response to an action signed by the user (does not include incoming token transfers). This maybe a user initiated transfer, burn tx etc"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Reference tx"),": Txs just preceding the exit tx for that particular user and token. As defined in our account balance based UTXO scheme, the outputs to the reference tx become the inputs to the tx being exited from."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"MoreVP exit priority"),": Age of the youngest input (among the reference txs) to a particular tx. It\u2019ll most often be used for calculating the exit priority.")),(0,r.kt)("h3",{id:"burn-tokens"},"Burn tokens"),(0,r.kt)("p",null,"To exit the sidechain, a user would launch a\xa0",(0,r.kt)("em",{parentName:"p"},"withdraw aka burn tokens"),"\xa0tx on the plasma chain. This tx will emit a\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"Withdraw"),"\xa0event."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"event Withdraw(\n    address indexed token,\n    address indexed from,\n    uint256 amountOrTokenId,\n    uint256 input1,\n    uint256 output1\n);\n")),(0,r.kt)("p",null,"Here\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"input1"),"\xa0denotes the user\u2019s previous balance for the token in question and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"output1"),"\xa0denotes the number of tokens left on the side chain. This construction is coherent with our account based\xa0",(0,r.kt)("em",{parentName:"p"},"UTXO"),"\xa0scheme. A user will present the receipt of this withdraw tx to withdraw the tokens on the main chain. While referencing this receipt, the user also has to provide the following:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Merkle proof of the inclusion of a receipt in a side chain block (",(0,r.kt)("inlineCode",{parentName:"li"},"receiptsRoot"),")"),(0,r.kt)("li",{parentName:"ol"},"Merkle proof of the inclusion of a transaction in a side chain block (",(0,r.kt)("inlineCode",{parentName:"li"},"transactionsRoot"),")"),(0,r.kt)("li",{parentName:"ol"},"Proof of the inclusion of the side chain block header in the checkpoint on the root chain")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"startExit(withdrawTx, proofOfInclusion /* of the withdrawTx in the checkpoint */) {\n  Verify inclusion of withdrawTx in checkpoint using proofOfInclusion\n  Verify msg.sender == ecrecover(withdrawTx)\n\n  uint age = getAge(withdrawTx)\n  // add exit to priority Q\n  PlasmaExit exit = ({owner, age, amount, token})\n  addExitToQueue(exit)\n}\n")),(0,r.kt)("p",null,"Whenever a user wishes to exit the plasma chain, they (or abstracted out by their client app i.e. wallet) should burn the tokens on the side chain, wait for it to get checkpointed and then start an exit from the checkpointed withdraw tx."),(0,r.kt)("h3",{id:"exit-from-the-last-erc20721-transfers-morevp"},"Exit from the last ERC20/721 transfers (MoreVP)"),(0,r.kt)("p",null,"Consider the scenario, user made a ERC20 transfer on the side chain. The operator added a out-of-nowhere tx just before the user\u2019s transfer and colluded with the validators to checkpoint this block. In this scenario and more generally, in the attack vectors A1 through A3 discussed above, the user may not have had the opportunity to burn their tokens before a malicious tx is included and hence would need to start an exit from the last checkpointed tx on the root chain - for this reason, in addition to the burn exit, we need to support exits from a variety of txs like ERC20/721 transfers among others. Building upon this attack vector and breaking down the 2 scenarios:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Outgoing transfer:")," I transferred some tokens to a user, however I noticed that the operator included a malicious tx in the block/checkpoint before including my transfer tx. I need to start exiting the chain. I\u2019ll start an exit from the transfer tx. As defined in MoreVP, I\u2019ll need to provide a reference tx (",(0,r.kt)("em",{parentName:"p"},"input UTXO"),") that\u2019ll define the exit priority of the exit. So, I\u2019ll reference a tx that updated my token balance and just precedes the outgoing transfer tx."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"startExit(referenceTx, proofOfInclusion, exitTx) {\n  Verify inclusion of referenceTx in checkpoint using proofOfInclusion\n  Verify token balance for the user after the input tx was executed >= tokens being transferred in the exitTx\n  Verify msg.sender == ecrecover(exitTx)\n\n  uint age = getAge(referenceTx)\n  // add exit to priority Q\n  PlasmaExit exit = ({owner, age, amount, token})\n  addExitToQueue(exit)\n}\n\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Incoming transfer:")," I noticed that the operator included a malicious tx in the block/checkpoint before including my incoming transfer tx.I\u2019ll start an exit from the incoming transfer tx while referencing the counterparty\u2019s balance - because here the\xa0",(0,r.kt)("em",{parentName:"p"},"input UTXO"),"\xa0is the counterparty\u2019s token balance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"startExit(referenceTx, proofOfInclusion, exitTx) {\n  Verify inclusion of referenceTx in checkpoint using proofOfInclusion\n  Verify token balance for the counterparty after the input tx was executed >= tokens being transferred in the exitTx\n  Verify input.sender == ecrecover(exitTx) && input.receiver == msg.sender\n\n  uint age = getAge(referenceTx)\n  // add exit to priority Q\n  PlasmaExit exit = ({owner, age, amount, token})\n  addExitToQueue(exit)\n}\n\n")),(0,r.kt)("h3",{id:"exit-from-an-in-flight-transaction-morevp"},"Exit from an in-flight transaction (MoreVP)"),(0,r.kt)("p",null,"This scenario is to combat data unavailability scenario. Let\u2019s say I made a tx but I do not know whether that tx has been included due to data unavailability. I can start an exit from this in-flight tx by referencing the last checkpointed tx. The user should be careful not to make any txs whenever they start a MoreVP style exit, otherwise they will be challenged."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Notes:")," When exiting from a MoreVP style construction, a user can start an exit by providing reference txs, exit tx and placing a small\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"exit bond"),". For any exit, if the exit is successfully challenged, the exit will be cancelled and exit bond will be seized."),(0,r.kt)("h2",{id:"limitations"},"Limitations"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Large proof size: Merkle proof of the inclusion of the transaction and merkle proof of the inclusion of block (that contains that transaction) in the checkpoint."),(0,r.kt)("li",{parentName:"ol"},"Mass exit: If the operator turns malicious, the users need to start mass exiting.")),(0,r.kt)("p",null,"The spec is in a nascent stage and we would appreciate any feedback that helps us improve it or redesign altogether if this construction is hopelessly broken. The implementation is a work in progress in our ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/contracts"},"contracts")," repository."))}d.isMDXComponent=!0}}]);