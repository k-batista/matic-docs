"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[58505],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return u}});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),m=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=m(e.components);return a.createElement(p.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=m(t),u=r,h=d["".concat(p,".").concat(u)]||d[u]||l[u]||o;return t?a.createElement(h,s(s({ref:n},c),{},{components:t})):a.createElement(h,s({ref:n},c))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=d;var i={};for(var p in n)hasOwnProperty.call(n,p)&&(i[p]=n[p]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var m=2;m<o;m++)s[m]=t[m];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},77675:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return p},default:function(){return u},frontMatter:function(){return i},metadata:function(){return m},toc:function(){return l}});var a=t(87462),r=t(63366),o=(t(67294),t(3905)),s=["components"],i={id:"code_organization",title:"Code Organization",sidebar_label:"Code Organization",description:"Miden assembly's code structure.",keywords:["docs","matic","polygon","miden","assembly"],image:"https://wiki.polygon.technology/img/thumbnail/polygon-miden.png"},p=void 0,m={unversionedId:"miden/user_docs/assembly/code_organization",id:"miden/user_docs/assembly/code_organization",title:"Code Organization",description:"Miden assembly's code structure.",source:"@site/docs/miden/user_docs/assembly/code_organization.md",sourceDirName:"miden/user_docs/assembly",slug:"/miden/user_docs/assembly/code_organization",permalink:"/matic-docs/docs/miden/user_docs/assembly/code_organization",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/miden/user_docs/assembly/code_organization.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686626387,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"code_organization",title:"Code Organization",sidebar_label:"Code Organization",description:"Miden assembly's code structure.",keywords:["docs","matic","polygon","miden","assembly"],image:"https://wiki.polygon.technology/img/thumbnail/polygon-miden.png"},sidebar:"miden",previous:{title:"Overview",permalink:"/matic-docs/docs/miden/user_docs/assembly/main"},next:{title:"Flow Control",permalink:"/matic-docs/docs/miden/user_docs/assembly/flow_control"}},c={},l=[{value:"Procedures",id:"procedures",level:3},{value:"Modules",id:"modules",level:3},{value:"Library modules",id:"library-modules",level:4},{value:"Programs",id:"programs",level:4},{value:"Importing modules",id:"importing-modules",level:4},{value:"Constants",id:"constants",level:3},{value:"Comments",id:"comments",level:3}],d={toc:l};function u(e){var n=e.components,t=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"A Miden assembly program is just a sequence of instructions each describing a specific directive or an operation. You can use any combination of whitespace characters to separate one instruction from another."),(0,o.kt)("p",null,"In turn, Miden assembly instructions are just keywords which can be parameterized by zero or more parameters. The notation for specifying parameters is ",(0,o.kt)("em",{parentName:"p"},"keyword.param1.param2")," - i.e., the parameters are separated by periods. For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"push.123")," instruction denotes a ",(0,o.kt)("inlineCode",{parentName:"p"},"push")," operation which is parameterized by value ",(0,o.kt)("inlineCode",{parentName:"p"},"123"),"."),(0,o.kt)("p",null,"Miden assembly programs are organized into procedures. Procedures, in turn, can be grouped into modules."),(0,o.kt)("h3",{id:"procedures"},"Procedures"),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"procedure")," can be used to encapsulate a frequently-used sequence of instructions which can later be invoked via a label. A procedure must start with a ",(0,o.kt)("inlineCode",{parentName:"p"},"proc.<label>.<number of locals>")," instruction and terminate with an ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," instruction. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"proc.foo.2\n    <instructions>\nend\n")),(0,o.kt)("p",null,"A procedure label must start with a letter and can contain any combination of numbers, ASCII letters, and underscores (",(0,o.kt)("inlineCode",{parentName:"p"},"_"),"). The number of characters in the procedure label cannot exceed 100."),(0,o.kt)("p",null,"The number of locals specifies the number of memory-based local words a procedure can access (via ",(0,o.kt)("inlineCode",{parentName:"p"},"loc_load"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"loc_store"),", and ",(0,o.kt)("a",{parentName:"p",href:"/matic-docs/docs/miden/user_docs/assembly/io_operations#random-access-memory"},"other instructions"),"). If a procedure doesn't need any memory-based locals, this parameter can be omitted or set to ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),". A procedure can have at most ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("msup",{parentName:"mrow"},(0,o.kt)("mn",{parentName:"msup"},"2"),(0,o.kt)("mn",{parentName:"msup"},"16"))),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"2^{16}")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mord"},"2"),(0,o.kt)("span",{parentName:"span",className:"msupsub"},(0,o.kt)("span",{parentName:"span",className:"vlist-t"},(0,o.kt)("span",{parentName:"span",className:"vlist-r"},(0,o.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,o.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,o.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,o.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},"16")))))))))))))," locals, and the total number of locals available to all procedures at runtime is limited to ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("msup",{parentName:"mrow"},(0,o.kt)("mn",{parentName:"msup"},"2"),(0,o.kt)("mn",{parentName:"msup"},"30"))),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"2^{30}")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mord"},"2"),(0,o.kt)("span",{parentName:"span",className:"msupsub"},(0,o.kt)("span",{parentName:"span",className:"vlist-t"},(0,o.kt)("span",{parentName:"span",className:"vlist-r"},(0,o.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,o.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,o.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,o.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},"30"))))))))))))),"."),(0,o.kt)("p",null,"To execute a procedure, the ",(0,o.kt)("inlineCode",{parentName:"p"},"exec.<label>"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"call.<label>"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"syscall.<label>")," instructions can be used. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"exec.foo\n")),(0,o.kt)("p",null,"The difference between using each of these instructions is explained in the ",(0,o.kt)("a",{parentName:"p",href:"/matic-docs/docs/miden/user_docs/assembly/execution-context#procedure-invocation-semantics"},"next section"),"."),(0,o.kt)("p",null,"A procedure may execute any other previously defined procedure, but it cannot execute itself or any of the subsequent procedures. Thus, recursive procedure calls are not possible. For example, the following code block defines a program with two procedures:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"proc.foo\n    <instructions>\nend\n\nproc.bar\n    <instructions>\n    exec.foo\n    <instructions>\nend\n\nbegin\n    <instructions>\n    exec.bar\n    <instructions>\n    exec.foo\nend\n")),(0,o.kt)("h3",{id:"modules"},"Modules"),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"module")," consists of one or more procedures. There are two types of modules: ",(0,o.kt)("em",{parentName:"p"},"library modules")," and ",(0,o.kt)("em",{parentName:"p"},"executable modules")," (also called ",(0,o.kt)("em",{parentName:"p"},"programs"),")."),(0,o.kt)("h4",{id:"library-modules"},"Library modules"),(0,o.kt)("p",null,"Library modules contain zero or more internal procedures and one or more exported procedures. For example, the following module defines one internal procedure (defined with ",(0,o.kt)("inlineCode",{parentName:"p"},"proc")," instruction) and one exported procedure (defined with ",(0,o.kt)("inlineCode",{parentName:"p"},"export")," instruction):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"proc.foo\n    <instructions>\nend\n\nexport.bar\n    <instructions>\n    exec.foo\n    <instructions>\nend\n")),(0,o.kt)("h4",{id:"programs"},"Programs"),(0,o.kt)("p",null,"Executable modules are used to define programs. A program contains zero or more internal procedures (defined with ",(0,o.kt)("inlineCode",{parentName:"p"},"proc")," instruction) and exactly one main procedure (defined with ",(0,o.kt)("inlineCode",{parentName:"p"},"begin")," instruction). For example, the following module defines one internal procedure and a main procedure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"proc.foo\n    <instructions>\nend\n\nbegin\n    <instructions>\n    exec.foo\n    <instructions>\nend\n")),(0,o.kt)("p",null,"A program cannot contain any exported procedures."),(0,o.kt)("p",null,"When a program is executed, the execution starts at the first instruction following the ",(0,o.kt)("inlineCode",{parentName:"p"},"begin")," instruction. The main procedure is expected to be the last procedure in the program and can be followed only by comments."),(0,o.kt)("h4",{id:"importing-modules"},"Importing modules"),(0,o.kt)("p",null,"To invoke a procedure from an external module, the module first needs to be imported using a ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," instruction. Once a module is imported, procedures from this module can be invoked via the regular ",(0,o.kt)("inlineCode",{parentName:"p"},"exec")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"call")," instructions as ",(0,o.kt)("inlineCode",{parentName:"p"},"exec|call.<module>::<label>")," where ",(0,o.kt)("inlineCode",{parentName:"p"},"label")," is the name of the procedure. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"use.std::math::u64\n\nbegin\n    push.1.0\n    push.2.0\n    exec.u64::checked_add\nend\n")),(0,o.kt)("p",null,"In the above example we import ",(0,o.kt)("inlineCode",{parentName:"p"},"std::math::u64")," module from the ",(0,o.kt)("a",{parentName:"p",href:"/matic-docs/docs/miden/user_docs/stdlib/main"},"standard library"),". We then execute a program which pushes two 64-bit integers onto the stack, and then invokes a 64-bit addition procedure from the imported module."),(0,o.kt)("p",null,"The set of modules which can be imported by a program can be specified via a Module Provider when instantiating the ",(0,o.kt)("a",{parentName:"p",href:"https://crates.io/crates/miden-assembly"},"Miden Assembler")," used to compile the program."),(0,o.kt)("h3",{id:"constants"},"Constants"),(0,o.kt)("p",null,"Miden assembly supports constant declarations. These constants are scoped to the module they are defined in and can be used as immediate parameters for Miden assembly instructions. Currently only ",(0,o.kt)("inlineCode",{parentName:"p"},"push")," instruction supports this."),(0,o.kt)("p",null,"Constants must be declared right after module imports and before any procedures or program bodies. A constant's name must start with an upper-case letter and can contain any combination of numbers, upper-case ASCII letters, and underscores (",(0,o.kt)("inlineCode",{parentName:"p"},"_"),"). The number of characters in a constant name cannot exceed 100."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"use.std::math::u64\n\nconst.CONSTANT_1=100\nconst.CONSTANT_2=200\n\nbegin\n    push.CONSTANT_1.CONSTANT_2\n    exec.u64::checked_add\nend\n\n")),(0,o.kt)("h3",{id:"comments"},"Comments"),(0,o.kt)("p",null,"Miden assembly allows annotating code with simple comments. There are two types of comments: single-line comments which start with a ",(0,o.kt)("inlineCode",{parentName:"p"},"#")," (pound) character, and documentation comments which start with ",(0,o.kt)("inlineCode",{parentName:"p"},"#!")," characters. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"#! This is a documentation comment\nexport.foo\n    # this is a comment\n    push.1\nend\n")),(0,o.kt)("p",null,"Documentation comments must precede a procedure declaration. Using them inside a procedure body is an error."))}u.isMDXComponent=!0}}]);