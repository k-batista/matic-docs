"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[22090],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),h=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=h(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},l=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),l=h(n),d=i,f=l["".concat(c,".").concat(d)]||l[d]||u[d]||o;return n?r.createElement(f,a(a({ref:t},p),{},{components:n})):r.createElement(f,a({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=l;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var h=2;h<o;h++)a[h]=n[h];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}l.displayName="MDXCreateElement"},77552:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return s},metadata:function(){return h},toc:function(){return u}});var r=n(87462),i=n(63366),o=(n(67294),n(3905)),a=["components"],s={id:"checkpoint",title:"Ensuring Data Integrity through Checkpoint Management",sidebar_label:"Ensuring data integrity through checkpoint management",description:"An overview of the checkpointing mechanism of Supernets.",keywords:["docs","polygon","edge","bridge","fxportal","checkpoint"]},c=void 0,h={unversionedId:"supernets/design/bridge/checkpoint",id:"supernets/design/bridge/checkpoint",title:"Ensuring Data Integrity through Checkpoint Management",description:"An overview of the checkpointing mechanism of Supernets.",source:"@site/docs/supernets/design/bridge/checkpoint.md",sourceDirName:"supernets/design/bridge",slug:"/supernets/design/bridge/checkpoint",permalink:"/matic-docs/docs/supernets/design/bridge/checkpoint",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/supernets/design/bridge/checkpoint.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686624865,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"checkpoint",title:"Ensuring Data Integrity through Checkpoint Management",sidebar_label:"Ensuring data integrity through checkpoint management",description:"An overview of the checkpointing mechanism of Supernets.",keywords:["docs","polygon","edge","bridge","fxportal","checkpoint"]},sidebar:"supernets",previous:{title:"Synchronizing chain state between rootchain and Supernet",permalink:"/matic-docs/docs/supernets/design/bridge/statesync"},next:{title:"Native assets",permalink:"/matic-docs/docs/category/native-assets"}},p={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Checkpoints in Supernets",id:"checkpoints-in-supernets",level:2},{value:"CheckpointManager",id:"checkpointmanager",level:3}],l={toc:u};function d(e){var t=e.components,n=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This documents provides an overview on how checkpointing works when using the native Supernets bridge."),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Checkpointing is the process of recording and committing a snapshot of the state of a system at a specific point in time. In the context of blockchain, checkpoints are used to increase security by allowing faster verification of the state of the blockchain without needing to process all transactions from the genesis block. Checkpoints can be used to speed up sync times for new nodes and help prevent certain types of attacks, such as 51% attacks."),(0,o.kt)("h2",{id:"checkpoints-in-supernets"},"Checkpoints in Supernets"),(0,o.kt)("admonition",{title:"Key points",type:"info"},(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"The checkpoints are made ",(0,o.kt)("strong",{parentName:"li"},"by the validators on the Supernet")," and are committed to the rootchain."),(0,o.kt)("li",{parentName:"ul"},"A checkpoint serves as a snapshot of the Supernet state. This snapshot is stored as a Merkle root and ",(0,o.kt)("strong",{parentName:"li"},"represents the state of the Supernet")," at that point in time it was created."),(0,o.kt)("li",{parentName:"ul"},"The checkpoint process is important for ",(0,o.kt)("strong",{parentName:"li"},"ensuring the security of the network")," as it enables the rootchain to detect and prevent any potential fraud or malicious activity on the child."))),(0,o.kt)("h3",{id:"checkpointmanager"},"CheckpointManager"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"CheckpointManager")," contract responsible for managing checkpoints in the network."),(0,o.kt)("p",null,"The checkpoints represent a snapshot of the Supernet state, which is periodically checkpointed to the rootchain by the validators. The checkpoints are used as a reference point for the rootchain to verify the integrity and accuracy of the data on the Supernet."),(0,o.kt)("p",null,"The contract has several functions to facilitate the management of checkpoints, such as submitting a new checkpoint with metadata, verifying signatures, and getting the event root by block number or epoch. The contract also has a mapping to store the checkpoints and the current validator set, and an array to keep track of the checkpoint block numbers."),(0,o.kt)("p",null,"The contract uses a Merkle tree to efficiently prove the membership of an event in the Supernet state. The tree is constructed using the hashed exit events sent by the L2StateSender, which the Edge client saves to its local storage after their transactions are executed. The membership proofs can be verified using the Merkle proofs provided by the users."),(0,o.kt)("p",null,"The contract also implements a BLS signature scheme to verify the signatures submitted by the validators. The validators' signatures are aggregated, and the contract checks whether the required voting power threshold is met to accept the checkpoint."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Details of the checkpoint"),(0,o.kt)("p",null,"To elaborate, the root of the Merkle tree is a hash value that represents a specific subset of the Supernet state at a specific point in time. This state includes only the exit events sent by the L2StateSender contract. When a user wants to exit the L2 chain (transfer their tokens from L2 to L1), their exit transaction is included in this Merkle tree."),(0,o.kt)("p",null,"When a checkpoint is made, the root of the Merkle tree is included as part of the checkpoint, along with other metadata. This checkpoint is then sent to the rootchain where it is verified and stored by the validators."),(0,o.kt)("p",null,"Later, when a user wants to verify a particular exit event on the Supernet, they can provide a Merkle proof, which is a cryptographic proof that demonstrates the inclusion of a particular exit event in the Merkle tree. The Merkle proof can be verified by the rootchain using the root of the Merkle tree, which was included in the checkpoint."),(0,o.kt)("p",null,"In short, the root of the Merkle tree is a compact representation of the exit events on the Supernet at a specific point in time, which is included in checkpoints and used for verification purposes.")))}d.isMDXComponent=!0}}]);