"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[72286],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return m}});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(a),m=i,k=p["".concat(s,".").concat(m)]||p[m]||u[m]||o;return a?n.createElement(k,r(r({ref:t},c),{},{components:a})):n.createElement(k,r({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var d=2;d<o;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},2342:function(e,t,a){a.r(t),a.d(t,{assets:function(){return u},contentTitle:function(){return d},default:function(){return k},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var n=a(87462),i=a(63366),o=(a(67294),a(3905)),r=a(44996),l=["components"],s={id:"stakingmanager",title:"Staking Manager",description:"Staking Manager is the main contract for handling validator-related activities on Polygon network.",keywords:["docs","Staking Manager","polygon","wiki","validator"],image:"https://wiki.polygon.technology/img/polygon-logo.png"},d=void 0,c={unversionedId:"pos/contracts/stakingmanager",id:"pos/contracts/stakingmanager",title:"Staking Manager",description:"Staking Manager is the main contract for handling validator-related activities on Polygon network.",source:"@site/docs/pos/contracts/stakingmanager.md",sourceDirName:"pos/contracts",slug:"/pos/contracts/stakingmanager",permalink:"/matic-docs/docs/pos/contracts/stakingmanager",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/pos/contracts/stakingmanager.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686625626,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"stakingmanager",title:"Staking Manager",description:"Staking Manager is the main contract for handling validator-related activities on Polygon network.",keywords:["docs","Staking Manager","polygon","wiki","validator"],image:"https://wiki.polygon.technology/img/polygon-logo.png"},sidebar:"pos",previous:{title:"Contracts",permalink:"/matic-docs/docs/category/contracts"},next:{title:"Delegation",permalink:"/matic-docs/docs/pos/contracts/delegation"}},u={},p=[{value:"Validator Admissions / Replacement",id:"validator-admissions--replacement",level:2},{value:"Admissions",id:"admissions",level:3},{value:"Replacement",id:"replacement",level:3},{value:"Methods and Variables",id:"methods-and-variables",level:2},{value:"validatorThreshold",id:"validatorthreshold",level:3},{value:"AccountStateRoot",id:"accountstateroot",level:3},{value:"stake / stakeFor",id:"stake--stakefor",level:3},{value:"unstake",id:"unstake",level:3},{value:"unstakeClaim",id:"unstakeclaim",level:3},{value:"restake",id:"restake",level:3},{value:"withdrawRewards",id:"withdrawrewards",level:3},{value:"updateSigner",id:"updatesigner",level:3},{value:"topUpForFee",id:"topupforfee",level:3},{value:"claimFee",id:"claimfee",level:3},{value:"StakingNFT",id:"stakingnft",level:3},{value:"startAuction",id:"startauction",level:3},{value:"confirmAuctionBid",id:"confirmauctionbid",level:3},{value:"checkSignatures",id:"checksignatures",level:3},{value:"isValidator",id:"isvalidator",level:3},{value:"Timeline Data Structure",id:"timeline-data-structure",level:2},{value:"StakingInfo",id:"stakinginfo",level:2},{value:"ValidatorShareFactory",id:"validatorsharefactory",level:2}],m={toc:p};function k(e){var t=e.components,a=(0,i.Z)(e,l);return(0,o.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"For the Polygon's Proof of Security based consensus, all the \u2154+1 proof verification and handling of staking, rewards are executed on the Ethereum smart contract. The whole design follows this philosophy of doing less on the Mainnet contract. It does information verification and pushes all the computation-heavy operations to L2 (read about ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.polygon.technology/docs/pos/heimdall/overview"},"Heimdall"),")."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Stakers")," are divided into ",(0,o.kt)("strong",{parentName:"p"},"validators"),", ",(0,o.kt)("strong",{parentName:"p"},"delegators"),", and ",(0,o.kt)("strong",{parentName:"p"},"watchers")," (for fraud reporting)."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/contracts/blob/develop/contracts/staking/stakeManager/StakeManager.sol"},(0,o.kt)("strong",{parentName:"a"},"StakeManager"))," is the main contract for handling validator related activities like ",(0,o.kt)("inlineCode",{parentName:"p"},"checkPoint")," signature verification, reward distribution, and stake management. Since the contract is using ",(0,o.kt)("strong",{parentName:"p"},"NFT ID")," as a source of ownership, change of ownership and signer won't affect anything in the system."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"From one Ethereum address, a ",(0,o.kt)("strong",{parentName:"p"},"Staker can only be a validator or delegator")," (it's just a design choice, no hard reasons).")),(0,o.kt)("h2",{id:"validator-admissions--replacement"},"Validator Admissions / Replacement"),(0,o.kt)("h3",{id:"admissions"},"Admissions"),(0,o.kt)("p",null,"At present, there are no open validator slots available on Polygon PoS. There is also a waitlist to become a validator. In the future, if slots become available, validators may apply to be considered and removed off of the waitlist."),(0,o.kt)("h3",{id:"replacement"},"Replacement"),(0,o.kt)("p",null,"PIP4 introduced the concept of showcasing validator performance for community visibility. If a validator is in an unhealthy state for an extended period of time as outlined in PIP4, they are off-boarded from the network. The validator slot is then made available to those coming off of the waitlist."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Currently, ",(0,o.kt)("a",{parentName:"p",href:"https://forum.polygon.technology/t/pip-4-validator-performance-management/9956/24"},(0,o.kt)("ins",null,"Phase 2 of PART C in PIP4"))," is being implemented. This is where the community decides on validator prospect evaluation criteria. In time, this exercise will produce an application and admissions process.")),(0,o.kt)("h2",{id:"methods-and-variables"},"Methods and Variables"),(0,o.kt)("admonition",{title:"Slashing Implementation",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("inlineCode",{parentName:"p"},"jail"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"unJail"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"slash")," functions are not used currently as part of the slashing implementation.")),(0,o.kt)("h3",{id:"validatorthreshold"},"validatorThreshold"),(0,o.kt)("p",null,"It stores the maximum number of validators accepted by the system, also called slots."),(0,o.kt)("h3",{id:"accountstateroot"},"AccountStateRoot"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For various accounting done on Heimdall for validators and delegator, account root is submitted while submitting the ",(0,o.kt)("inlineCode",{parentName:"li"},"checkpoint"),"."),(0,o.kt)("li",{parentName:"ul"},"accRoot is used while ",(0,o.kt)("inlineCode",{parentName:"li"},"claimRewards")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"unStakeClaim"),".")),(0,o.kt)("h3",{id:"stake--stakefor"},"stake / stakeFor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="StakeManager.sol"',title:'"StakeManager.sol"'},"function stake(\n    uint256 amount,\n    uint256 heimdallFee,\n    bool acceptDelegation,\n    bytes calldata signerPubkey\n) public;\n\nfunction stakeFor(\n    address user,\n    uint256 amount,\n    uint256 heimdallFee,\n    bool acceptDelegation,\n    bytes memory signerPubkey\n) public;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Allows anyone with amount (in MATIC tokens) greater than ",(0,o.kt)("inlineCode",{parentName:"li"},"minDeposit"),", if ",(0,o.kt)("inlineCode",{parentName:"li"},"currentValidatorSetSize")," is less then ",(0,o.kt)("inlineCode",{parentName:"li"},"validatorThreshold"),"."),(0,o.kt)("li",{parentName:"ul"},"Must transfer ",(0,o.kt)("inlineCode",{parentName:"li"},"amount+heimdallFee"),", puts validator into auction period for an auctionInterval (more in Auction section)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateTimeLine")," updates special timeline data structure, which keeps track of active validators and active stake for given epoch / checkpoint count."),(0,o.kt)("li",{parentName:"ul"},"One unique ",(0,o.kt)("inlineCode",{parentName:"li"},"NFT")," is minted on each new ",(0,o.kt)("inlineCode",{parentName:"li"},"stake")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"stakeFor")," call, which can be transferred to anyone but can be owned 1:1 Ethereum address."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"acceptDelegation")," set to true if validators want to accept delegation, ",(0,o.kt)("inlineCode",{parentName:"li"},"ValidatorShare")," contract is deployed for the validator.")),(0,o.kt)("h3",{id:"unstake"},"unstake"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Remove validator from validator set in next epoch (only valid for current checkpoint once called ",(0,o.kt)("inlineCode",{parentName:"li"},"unstake"),")"),(0,o.kt)("li",{parentName:"ul"},"Remove validator's stake from timeline data structure, update count for validator's exit epoch."),(0,o.kt)("li",{parentName:"ul"},"If validator had delegation on, collect all rewards and lock delegation contract for new delegations.")),(0,o.kt)("h3",{id:"unstakeclaim"},"unstakeClaim"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function unstakeClaim(uint256 validatorId) public;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"After ",(0,o.kt)("inlineCode",{parentName:"li"},"unstaking"),", validators are put into withdrawal period so that they can be slashed, if any fraud found after ",(0,o.kt)("inlineCode",{parentName:"li"},"unstaking"),", for past frauds."),(0,o.kt)("li",{parentName:"ul"},"Once ",(0,o.kt)("inlineCode",{parentName:"li"},"WITHDRAWAL_DELAY")," period is served, validators can call this function and do settlement with ",(0,o.kt)("inlineCode",{parentName:"li"},"stakeManager")," (get rewards if any, get staked tokens back, burn NFT, etc).")),(0,o.kt)("h3",{id:"restake"},"restake"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function restake(uint256 validatorId, uint256 amount, bool stakeRewards) public;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Allows validators to increase their stake by putting new amount or rewards or both."),(0,o.kt)("li",{parentName:"ul"},"Must update timeline (amount) for active stake.")),(0,o.kt)("h3",{id:"withdrawrewards"},"withdrawRewards"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function withdrawRewards(uint256 validatorId) public;\n")),(0,o.kt)("p",null,"This method allows validators to withdraw accumulated rewards, must consider getting rewards from delegation contract if validator accepts delegation."),(0,o.kt)("h3",{id:"updatesigner"},"updateSigner"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function updateSigner(uint256 validatorId, bytes memory signerPubkey) public\n")),(0,o.kt)("p",null,"This method allows validators to update signer address (which is used to validate blocks on Polygon blockchain and checkpoint signatures on ",(0,o.kt)("inlineCode",{parentName:"p"},"stakeManager"),")."),(0,o.kt)("h3",{id:"topupforfee"},"topUpForFee"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function topUpForFee(uint256 validatorId, uint256 heimdallFee) public;\n")),(0,o.kt)("p",null,"Validators can top-up their balance for Heimdall fee by invoking this method."),(0,o.kt)("h3",{id:"claimfee"},"claimFee"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function claimFee(\n        uint256 validatorId,\n        uint256 accumSlashedAmount,\n        uint256 accumFeeAmount,\n        uint256 index,\n        bytes memory proof\n    ) public;\n")),(0,o.kt)("p",null,"This method is used to withdraw fees from Heimdall. ",(0,o.kt)("inlineCode",{parentName:"p"},"accountStateRoot")," is updated on each checkpoint, so that validators can provide proof of inclusion in this root for account on Heimdall and withdraw fee."),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"accountStateRoot")," is re-written to prevent exits on multiple checkpoints (for old root and save accounting on ",(0,o.kt)("inlineCode",{parentName:"p"},"stakeManager"),"). ",(0,o.kt)("inlineCode",{parentName:"p"},"accumSlashedAmount")," is unused at the moment and will be used for slashing on Heimdall if needed."),(0,o.kt)("h3",{id:"stakingnft"},"StakingNFT"),(0,o.kt)("p",null,"Standard ERC721 contract with few restrictions like one token per user and minted in sequential manner."),(0,o.kt)("h3",{id:"startauction"},"startAuction"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function startAuction(\n    uint256 validatorId, /**  auction for validator */\n    uint256 amount /**  amount greater then old validator's stake */\n    ) external;\n")),(0,o.kt)("p",null,"In order to start a bid or bid higher on already running auction, this function is used. Auction period runs in cycles like ",(0,o.kt)("inlineCode",{parentName:"p"},"(auctionPeriod--dynasty)--(auctionPeriod--dynasty)--(auctionPeriod--dynasty)")," so it ",(0,o.kt)("strong",{parentName:"p"},"must check for correct auction period"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"perceivedStakeFactor")," is used to calculate exact factor*old stake (note currently it is by default 1 WIP for picking the function). ",(0,o.kt)("strong",{parentName:"p"},"Must check for auction from last auction period if any still going on")," (one can choose to not call ",(0,o.kt)("inlineCode",{parentName:"p"},"confirmAuction")," in order to get their capital out in the next auction). Normally continuous english auction is going on in a ",(0,o.kt)("inlineCode",{parentName:"p"},"auctionPeriod"),"."),(0,o.kt)("h3",{id:"confirmauctionbid"},"confirmAuctionBid"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function confirmAuctionBid(\n        uint256 validatorId,\n        uint256 heimdallFee, /** for new validator */\n        bool acceptDelegation,\n        bytes calldata signerPubkey\n    ) external\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Must check that this is not an auctionPeriod.")),(0,o.kt)("li",{parentName:"ul"},"If last bidder is owner of ",(0,o.kt)("inlineCode",{parentName:"li"},"validatorId"),", behaviour should be similar to restake."),(0,o.kt)("li",{parentName:"ul"},"In second case unStake ",(0,o.kt)("inlineCode",{parentName:"li"},"validatorId")," and add new user as validator from next checkpoint, for the new user behaviour should be similar to stake/stakeFor.")),(0,o.kt)("h3",{id:"checksignatures"},"checkSignatures"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function checkSignatures(\n        uint256 blockInterval,\n        bytes32 voteHash,\n        bytes32 stateRoot,\n        bytes memory sigs\n    ) public;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Writes are meant only for RootChain contract when submitting checkpoints"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"voteHash")," on which all validators sign (BFT \u2154+1 agreement)"),(0,o.kt)("li",{parentName:"ul"},"This function validates only unique sigs and checks for \u2154+1 power has signed on checkpoint root (inclusion in ",(0,o.kt)("inlineCode",{parentName:"li"},"voteHash")," verification in RootChain contract for all data) ",(0,o.kt)("inlineCode",{parentName:"li"},"currentValidatorSetTotalStake")," provides current active stake."),(0,o.kt)("li",{parentName:"ul"},"Rewards are distributed proportionally to validator's stake. More on rewards in ",(0,o.kt)("a",{parentName:"li",href:"https://www.notion.so/Rewards-Distribution-127d586c14544beb9ea326fd3bb5d3a2"},"Rewards Distribution"),".")),(0,o.kt)("h3",{id:"isvalidator"},"isValidator"),(0,o.kt)("p",null,"Checks if a given validator is active validator for the current epoch."),(0,o.kt)("h2",{id:"timeline-data-structure"},"Timeline Data Structure"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"struct State {\n    int256 amount;\n    int256 stakerCount;\n}\n\nmapping(uint256 => State) public validatorState;\n")),(0,o.kt)("img",{src:(0,r.Z)("img/staking_manager/staking_manager.png")}),(0,o.kt)("h2",{id:"stakinginfo"},"StakingInfo"),(0,o.kt)("p",null,"Centralized logging contract for both validator and delegation events, includes few read only functions. You can check out the source code of the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/contracts/blob/develop/contracts/staking/StakingInfo.sol"},"StakingInfo.sol")," contract on GitHub."),(0,o.kt)("h2",{id:"validatorsharefactory"},"ValidatorShareFactory"),(0,o.kt)("p",null,"A factory contract to deploy ",(0,o.kt)("inlineCode",{parentName:"p"},"ValidatorShare")," contract for each validator who opt-in for delegation. You can check out the source code of the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/contracts/blob/develop/contracts/staking/validatorShare/ValidatorShareFactory.sol"},"ValidatorShareFactory.sol")," contract on GitHub."))}k.isMDXComponent=!0}}]);