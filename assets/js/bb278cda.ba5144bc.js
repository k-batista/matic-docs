"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[69396],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),p=c(n),h=a,f=p["".concat(l,".").concat(h)]||p[h]||u[h]||i;return n?o.createElement(f,s(s({ref:t},d),{},{components:n})):o.createElement(f,s({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var c=2;c<i;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},25625:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return u}});var o=n(87462),a=n(63366),i=(n(67294),n(3905)),s=["components"],r={id:"ibft-overview",title:"Istanbul Byzantine Fault Tolerant (IBFT) 2.0",sidebar_label:"Istanbul Byzantine Fault Tolerant (IBFT) 2.0",description:"Learn about the consensus engine of Supernets.",keywords:["docs","polygon","edge","consensus","polybft","pos"]},l=void 0,c={unversionedId:"supernets/design/consensus/polybft/ibft-overview",id:"supernets/design/consensus/polybft/ibft-overview",title:"Istanbul Byzantine Fault Tolerant (IBFT) 2.0",description:"Learn about the consensus engine of Supernets.",source:"@site/docs/supernets/design/consensus/polybft/ibft.md",sourceDirName:"supernets/design/consensus/polybft",slug:"/supernets/design/consensus/polybft/ibft-overview",permalink:"/matic-docs/docs/supernets/design/consensus/polybft/ibft-overview",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/supernets/design/consensus/polybft/ibft.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686624865,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"ibft-overview",title:"Istanbul Byzantine Fault Tolerant (IBFT) 2.0",sidebar_label:"Istanbul Byzantine Fault Tolerant (IBFT) 2.0",description:"Learn about the consensus engine of Supernets.",keywords:["docs","polygon","edge","consensus","polybft","pos"]},sidebar:"supernets",previous:{title:"Polygon Byzantine Fault Tolerance (PolyBFT)",permalink:"/matic-docs/docs/supernets/design/consensus/polybft/polybft-overview"},next:{title:"Allowlisting validators",permalink:"/matic-docs/docs/supernets/design/consensus/validator/polybft-allowlist"}},d={},u=[{value:"Consensus Engine",id:"consensus-engine",level:2},{value:"State transitions",id:"state-transitions",level:3},{value:"Validator Set",id:"validator-set",level:3},{value:"Staking",id:"staking",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Consensus benefits",id:"consensus-benefits",level:3},{value:"Network benefits",id:"network-benefits",level:3}],p={toc:u};function h(e){var t=e.components,n=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This document presents an overview of the Istanbul Byzantine Fault Tolerant (IBFT) 2.0, the consensus engine of ",(0,i.kt)("a",{parentName:"p",href:"/docs/supernets/design/consensus/polybft/polybft-overview"},"PolyBFT"),"."),(0,i.kt)("h2",{id:"consensus-engine"},"Consensus Engine"),(0,i.kt)("p",null,"The PolyBFT consensus mechanism uses the IBFT 2.0 consensus engine to agree on adding new blocks to the blockchain. The validator pool in IBFT 2.0 is responsible for validating candidate blocks proposed by a randomly selected block proposer who is part of the validator pool. The proposer is responsible for constructing a block at the block interval. The proposer mechanism is based on ",(0,i.kt)("a",{parentName:"p",href:"https://tendermint.com/"},"Tendermint"),", where a proposer is chosen based on a deterministic selection algorithm. The frequency of selection is proportional to the voting power of the validator."),(0,i.kt)("p",null,"Each block in IBFT 2.0 requires at least one round of voting by the validator to arrive at consensus, which is recorded as a collection of signatures on the block content. In general, a supermajority of validators must confirm that a block is valid for the block to be added to the blockchain. Only when there is no consensus on a given block, multiple rounds of voting are needed. The ideal path would be when the validator pool reaches consensus on a candidate block in the first round of voting, and the block is added to the blockchain without the need for additional rounds of voting. This is the most efficient and optimal outcome, as it allows the network to continue processing transactions and adding new blocks to the chain in a timely manner."),(0,i.kt)("p",null,"A validator's voting power is proportional to the amount of stake they have locked up on the network. This means that validators with more stake will have more voting power and, therefore, more influence over the decision-making process on the network. This also provides an economic incentive for validators to behave honestly and act in the network's best interest."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Sealing a block"),(0,i.kt)("h3",{id:"state-transitions"},"State transitions"),(0,i.kt)("p",null,"PolyBFT's consensus mechanism follows a series of state transitions that ensure network-wide consensus on the blockchain's state. The consensus process starts with a validator proposing a new block to be added to the blockchain, which includes a list of transactions to update the blockchain's state."),(0,i.kt)("p",null,"Next, validators in the active set vote on whether to accept the proposed block. Each validator's voting weight determines their influence in voting, and a supermajority of validators must agree to accept the block for consensus to be reached. The protocol tracks the current block's position, also known as its ",(0,i.kt)("strong",{parentName:"p"},"sequence"),"."),(0,i.kt)("p",null,"The process to finalize a block in PolyBFT is referred to as ",(0,i.kt)("strong",{parentName:"p"},"sealing"),". When a validator proposes a new block, other validators vote on whether to accept it, and this process can be repeated multiple times. Each repetition is called a ",(0,i.kt)("strong",{parentName:"p"},"round"),', and during each round, a set number of validators must agree to seal the proposed block for it to be added to the blockchain. If the required number of votes isn\'t reached during a particular round, the voting process will continue into the next round, and the protocol "increases the round". Another validator will then attempt to seal the sequence in the new round.'),(0,i.kt)("p",null,"If the proposed block is accepted, it's added to the blockchain, and the state of the blockchain is updated to reflect the changes introduced by the transactions in the block. This process continues with the next proposer proposing a new block, and the process repeats.")),(0,i.kt)("h3",{id:"validator-set"},"Validator Set"),(0,i.kt)("p",null,"PolyBFT limits network participation to around 100 validators, and a variable amount of stake is used as a fixed stake criterion to limit the system's security and can make the system economically vulnerable. The validator set in the PolyBFT does not update on each block but is fixed during n block periods known as an epoch."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," block period to define one epoch is determined by governance, and until then, validators will remain the same. At the end of the epoch, a special state transaction to validatorSetManagementContract is emitted, notifying the system about the validators' uptime during the epoch. It is up to the smart contract to reward validators by their uptime and update the validator set for the next epoch. There is a function getValidatorSet which returns the current validator set at any time."),(0,i.kt)("admonition",{title:"Proposer selection algorithm - Section is being updated",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The proposer selection algorithm is Tendermint-based.")),(0,i.kt)("h3",{id:"staking"},"Staking"),(0,i.kt)("p",null,"Staking is managed by staking contracts on the Supernet. The staking module on Polygon validates staked tokens and is independent of Ethereum's security. In principle, the network is secured by the rootchain and Ethereum. Transaction checkpoints still occur on Ethereum, but Ethereum does not validate staking on Polygon."),(0,i.kt)("p",null,"At the end of each epoch, a reward calculation occurs to reward validators who actively participated in that epoch."),(0,i.kt)("admonition",{title:"Staking details and rewards - Section is being updated",type:"info"}),(0,i.kt)("h2",{id:"benefits"},"Benefits"),(0,i.kt)("h3",{id:"consensus-benefits"},"Consensus benefits"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Immediate block finality"),': Only one block is proposed at a given chain height; thus, the single chain removes forking, uncle blocks, and the risk that a transaction may be "undone" once on the chain later.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Reduced time between blocks"),": The effort needed to construct and validate blocks is decreased significantly, which increases the chain's throughput."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"High data integrity and fault tolerance"),": IBFT 2.0 uses a pool of validators to ensure the integrity of each proposed block. A supermajority (~66%) of these validators must sign the block before insertion into the chain, making block forgery very difficult. Also, the proposer of the block rotates over time, ensuring a faulty node cannot exert long-term influence over the chain."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Operationally flexible"),": The validators can be modified quickly, ensuring the group contains only fully trusted nodes.")),(0,i.kt)("h3",{id:"network-benefits"},"Network benefits"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Liveness"),": It has been proven that IBFT 2.0 does not guarantee BFT persistence nor liveness when operating on a synchronous network. If a validator receives enough confirmation about a block, it can lock the proposed block (assuming it has not locked any prior). If a change were to occur because of a fault in the network, it could trigger the activation of the round change protocol, where the protocol would expect to commit the locked block at that specific height."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Persistence"),": If, for instance, there is a faulty network condition present where two different node subsets lock to two different blocks, the system enters into an infinite cycle of state transitions that cannot converge states and finalize the block.")))}h.isMDXComponent=!0}}]);