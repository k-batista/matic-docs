"use strict";(self.webpackChunkmatic_docs=self.webpackChunkmatic_docs||[]).push([[36450],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return u}});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=a,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||i;return n?o.createElement(m,r(r({ref:t},h),{},{components:n})):o.createElement(m,r({ref:t},h))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},89509:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var o=n(87462),a=n(63366),i=(n(67294),n(3905)),r=["components"],s={id:"polybft",title:"PolyBFT",description:"Explanation about PolyBFT, the consensus mechanism for Polygon Edge.",keywords:["docs","polygon","edge","consensus","polybft","pos"]},l=void 0,c={unversionedId:"edge/consensus/polybft",id:"edge/consensus/polybft",title:"PolyBFT",description:"Explanation about PolyBFT, the consensus mechanism for Polygon Edge.",source:"@site/docs/edge/consensus/polybft.md",sourceDirName:"edge/consensus",slug:"/edge/consensus/polybft",permalink:"/matic-docs/docs/edge/consensus/polybft",draft:!1,editUrl:"https://github.com/maticnetwork/matic-docs/tree/master/docs/edge/consensus/polybft.md",tags:[],version:"current",lastUpdatedBy:"k-batista",lastUpdatedAt:1686624865,formattedLastUpdatedAt:"Jun 13, 2023",frontMatter:{id:"polybft",title:"PolyBFT",description:"Explanation about PolyBFT, the consensus mechanism for Polygon Edge.",keywords:["docs","polygon","edge","consensus","polybft","pos"]}},h={},p=[{value:"Overview",id:"overview",level:2},{value:"Consensus Engine: IBFT",id:"consensus-engine-ibft",level:2},{value:"Benefits of IBFT",id:"benefits-of-ibft",level:3},{value:"Tendermint-based re-locking mechanism",id:"tendermint-based-re-locking-mechanism",level:2},{value:"Benefits",id:"benefits",level:3},{value:"Consensus protocol: PolyBFT",id:"consensus-protocol-polybft",level:2}],d={toc:p};function u(e){var t=e.components,n=(0,a.Z)(e,r);return(0,i.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"All the client-based documentation is being revamped due to the new\nclient updates to Polygon Edge and is subject to change. Please stay\ntuned!"),(0,i.kt)("p",{parentName:"admonition"},"Please also feel free to raise an issue or pull request if you have any\nqueries or suggestions.")),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"PolyBFT is the consensus mechanism of Polygon Edge. It is composed of two\ncore parts, a consensus engine and a consensus protocol."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"                            +----------------------------+\n                            |           PolyBFT          |\n                            |          Consensus         |\n                            +----------------------------+\n                                            |\n                                            |\n                            --------------------------------\n                            |                              |\n                            |                              |\n              +--------------------------+    +--------------------------+\n              |          IBFT            |    |          Core            |\n              |        Consensus         |    |          Smart           |\n              |         Engine           |    |         Contracts        |\n              +--------------------------+    +--------------------------+\n")),(0,i.kt)("p",null,"PolyBFT uses an adaptation of PBFT (Practical Byzantine Fault Tolerance) consensus,\nknown as IBFT (Istanbul Byzantine Fault Tolerance), in combination with the Tendermint-based\nre-locking mechanism."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Recall that a Byzantine Fault Tolerance network is a\nnetwork that is resilient enough to function correctly\neven if some nodes are dishonest or malicious.\nA PBFT implementation, which IBFT is one of,\ncan tolerate up to ",(0,i.kt)("em",{parentName:"p"},"f")," faulty nodes in a\nnetwork of 3f + 1 nodes. The network remains fault tolerant so long as two-thirds of\nnodes are honest. This is sometimes referred to as a \u201csuper-majority rules\u201d algorithm.")),(0,i.kt)("p",null,"Each PolyBFT node maintains a local copy of the blockchain. The PolyBFT blockchain can be modeled\nas a list of blocks, like the Ethereum blockchain. The height of a block is defined as the number\nof parent links that separate the block from the genesis block, with height 0. The protocol runs\nsequential instances of a block finalization protocol, where the objective of the h-th instance is\nto decide which Ethereum block is to be added at height ",(0,i.kt)("inlineCode",{parentName:"p"},"h")," of the blockchain. In PolyBFT, the height\nis referred to as the ",(0,i.kt)("em",{parentName:"p"},"sequence"),"."),(0,i.kt)("h2",{id:"consensus-engine-ibft"},"Consensus Engine: IBFT"),(0,i.kt)("p",null,"Specifically, Polygon Edge uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/0xPolygon/go-ibft"},"IBFT 2.0")," as a consensus\nengine to seal blocks."),(0,i.kt)("p",null,"IBFT includes a validator pool (or set) responsible for validating candidate blocks proposed\nby a randomly selected block proposer who is part of the validator pool. The proposer is responsible\nfor constructing a block at the block interval. The proposer mechanism is based on Tendermint, where\na proposer is chosen based a deterministic selection algorithm. The frequency in selection is also\nproportional to the voting power of the validator."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The amount of voting power a validator has is proportional to the amount of stake that they have locked\nup on the network. This means that validators with more stake will have more voting power and, therefore,\nmore influence over the decision-making process on the network.")),(0,i.kt)("p",null,"Each block in IBFT requires multiple rounds of voting\nby the validator to arrive at consensus, which is recorded as a collection of signatures on the block\ncontent. A super-majority of validators must validate the block to be added to the blockchain."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},'The validator selection algorithm still needs to be determined. It will resemble the diagram,\nwhere x, y, z are input parameters related to the selection, the "Round #" is the current\nRound Number of the system, and "validator n" is the selected validator.'),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"       __________          __________          __________       __________\n      |          |        |          |        |          |     |          |\n      |    x     |        |    y     |        |    z     |     | Round #  |\n      |__________|        |__________|        |__________|     |__________|\n          |                 |                    |                 |\n          |                 |                    |                 |\n          |                 |                    |                 |\n       _______________________________________________________________________\n      |                                                                       |\n      |                validator proposer selection algorithm                 |\n      |_______________________________________________________________________|\n                                          |\n                                          |\n                               _______________________\n                              |                       |\n                              |      validator n      |\n                              |_______________________|\n"))),(0,i.kt)("h3",{id:"benefits-of-ibft"},"Benefits of IBFT"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Immediate block finality"),": Only one block is proposed at a given chain height. Thus, the\nsingle chain removes forking,\nuncle blocks, and the risk that a transaction may be \u201cundone\u201d once on the chain later."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"The reduced time between blocks"),": The effort needed to construct and validate blocks is\ndecreased significantly and increases the chain's throughput."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"High data integrity and fault tolerance"),": IBFT uses a pool of validators to ensure the\nintegrity of each proposed block. A super-majority (~66%) of these validators are required to\nsign the block before insertion to the chain, making block forgery very difficult. Also, the\nproposer of the pool rotates over time \u2014 ensuring a faulty node cannot exert long-term influence\nover the chain."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Operationally flexible"),": The validators can be modified in time, ensuring the group contains\nonly full-trusted nodes.")),(0,i.kt)("h2",{id:"tendermint-based-re-locking-mechanism"},"Tendermint-based re-locking mechanism"),(0,i.kt)("p",null,"It has been proved that IBFT does not guarantee Byzantine-fault-tolerant persistence nor liveness\nwhen operating on an eventually synchronous network. As a result, PolyBFT uses a\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.tendermint.com/v0.34/introduction/what-is-tendermint.html"},"re-locking mechanism inspired by Tendermint"),"."),(0,i.kt)("p",null,"When a validator proposes a new block, their stake is locked up for a predetermined time. This\nhelps to ensure that the validator cannot create conflicting transactions during this time since any such\nattempts would result in losing their locked stake. After the lockup period has expired, the validator's\nstake is \"re-locked\" for another predetermined time. This helps prevent the validator from attempting to\ncreate additional conflicting transactions after the proposed first block. The re-locking mechanism helps\nto ensure the safety and integrity of the network by aligning the incentives of validators with the network's\nbest interests."),(0,i.kt)("h3",{id:"benefits"},"Benefits"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Liveness"),": It has been proven that IBFT does not guarantee BFT persistence nor liveness\nwhen operating on a synchronous network. If a validator receives enough confirmation about a block,\nit can lock the proposed block (assuming it has not locked any prior). If a change were to occur\nbecause of a fault in the network, it could trigger the activation of the round change protocol,\nwhere the protocol would expect to commit the locked block at that specific height.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Persistence"),": If, for instance, there is a faulty network condition present where two different\nnode subsets lock to two different blocks, the system enters into an infinite cycle of state transitions\nthat cannot converge states and finalize the block."))),(0,i.kt)("h2",{id:"consensus-protocol-polybft"},"Consensus protocol: PolyBFT"),(0,i.kt)("p",null,"The consensus protocol uses the IBFT consensus engine and proof-of-stake architecture to seal blocks,\nprovide specific network capabilities, and govern the network. The consensus engine works with a set of\ncore smart contracts that implements a staking solution and incentivization scheme which defines all the\nnetwork's proof-of-stake rules."),(0,i.kt)("p",null,"Polygon Edge follows ",(0,i.kt)("a",{parentName:"p",href:"/matic-docs/docs/maintain/delegate/delegate"},"delegated proof of stake consensus"),", where\ndelegators delegate their MATIC to back validators on the network."),(0,i.kt)("p",null,"The consensus protocol follows a set of state transitions. While things are still being finalized, the\nprocess will typically follow the steps below."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"A validator proposes a new block to be added to Polygon. This block contains a list of transactions\nthat the validator would like to include in the next update to the blockchain's state.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Other validators in the active set will vote on whether to accept the proposed block. A\ncertain number of validators must agree to accept the block to reach consensus. The voting weight of\neach validator influences voting. The protocol refers to block height as a ",(0,i.kt)("em",{parentName:"p"},"sequence"),"."),(0,i.kt)("p",{parentName:"li"}," The process to finalize a block in PolyBFT is known as ",(0,i.kt)("em",{parentName:"p"},"sealing"),". The sealing of blocks is instant\nand final. All nodes in the network exchange information for a given sequence."),(0,i.kt)("p",{parentName:"li"}," When a validator proposes a new block, other validators on the network will vote on whether to\naccept the block. This process is typically repeated several times; each repetition is known as a\n",(0,i.kt)("em",{parentName:"p"},"round"),'. During each round, a certain number of validators must agree to seal the proposed block\nfor it to be added to the blockchain. If the required number of votes is not reached during a\nparticular round, the voting process will continue into the next round, and thus, the protocol\n"increases the round". Another validator will attempt to seal the sequence in the new round.'),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"The best case for a proposed block is that it is sealed at round 0. If blocks are repeatedly being\nsealed at a high-order round, which usually indicates a problem with the network."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If the proposed block is accepted, it will be added to the blockchain, and the state of the blockchain\nwill be updated to reflect the changes introduced by the transactions in the block."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"If a malicious actor attempted to fork the network, they would need to obtain control of 2/3 of\nthe network, which PolyBFT prevents."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Once the state of the blockchain has been updated, the next proposer will propose a new block, and\nthe process repeats."))),(0,i.kt)("p",null,"IBFT limits network participation to around 100 validators. A variable amount of stake is used as a fixed\nstake criterion to limit the system's security and can make the system economically vulnerable. The\nvalidator set in the PolyBFT does not update on each block but is fixed during  ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," block periods known as\nan ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," block period to define one epoch is to be determined by governance. Until then, validators will\nremain the same. At the end of the epoch, a special ",(0,i.kt)("inlineCode",{parentName:"p"},"state transaction")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"ChildValidatorSet"),"\nis emitted, notifying the system about validators\u2019 uptime during the ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch"),". It is up to the smart contract\nto reward validators by their uptime and ",(0,i.kt)("strong",{parentName:"p"},"update the validator set")," for the next ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch"),". There is a\nfunction ",(0,i.kt)("inlineCode",{parentName:"p"},"getValidatorSet")," which returns the current validator set at any time.")),(0,i.kt)("p",null,"Staking is governed by staking contracts directly on Polygon. To be clear, the staking module validates on\nPolygon and does not rely on Ethereum's security, but in principle, two chains are securing the network, PoS\nclient and Ethereum. Transaction checkpoints still occur on Ethereum, but Ethereum does not validate staking\non Polygon."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Note that in Tendermint, an epoch is set to 1. However, PolyBFT includes the logic to set a custom\nepoch time, with the intent of each epoch being one day in blocks, or around 14000 blocks.")),(0,i.kt)("p",null,"A reward calculation occurs at the end of the epoch to reward the active validators in that epoch."),(0,i.kt)("admonition",{title:"Slashing",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Like in other proof-of-stake systems, validators are subject to slashing for malicious activity or\npoor performance. The slashing mechanics are still being determined, but PolyBFT will undoubtedly\ninclude a mechanism to penalize bad actors. Slashing a validator typically involves a penalty, such\nas losing some or all of their stake on the network."),(0,i.kt)("p",{parentName:"admonition"},"Examples of malicious activities are double-signing and equivocation."),(0,i.kt)("p",{parentName:"admonition"},"Double-signing refers to the act of signing two conflicting transactions. When a validator double-signs,\nit creates a situation where the network is unable to reach consensus on the state of the blockchain,\nwhich can lead to problems such as an attempt to fork or network instability."),(0,i.kt)("p",{parentName:"admonition"},"Equivocation is another behavior that can lead to validator slashing in a PoS network. Equivocation\nrefers to the act of a validator attempting to create two conflicting versions of the blockchain,\nwhich can also lead to problems such as fork or network instability.")))}u.isMDXComponent=!0}}]);